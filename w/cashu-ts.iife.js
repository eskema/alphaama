var eu=Object.defineProperty;var nu=(g,rt,mt)=>rt in g?eu(g,rt,{enumerable:!0,configurable:!0,writable:!0,value:mt}):g[rt]=mt;var k=(g,rt,mt)=>nu(g,typeof rt!="symbol"?rt+"":rt,mt);var cashuts=(function(g){"use strict";class rt extends Error{constructor(t,e){super(t),this.status=e,this.name="HttpResponseError",Object.setPrototypeOf(this,rt.prototype)}}class mt extends Error{constructor(t){super(t),this.name="NetworkError",Object.setPrototypeOf(this,mt.prototype)}}class we extends rt{constructor(t,e){super(e||"Unknown mint operation error",400),this.code=t,this.name="MintOperationError",Object.setPrototypeOf(this,we.prototype)}}const X={error(){},warn(){},info(){},debug(){},trace(){},log(){}};function be(r,t=X,e){throw t.error(r,e),new Error(r)}function hn(r,t,e=X,n){r&&be(t,e,n)}function Er(r,t,e=X,n){r==null&&be(t,e,n)}function Xt(r,t,e=X,n){if(r)try{const s=r(t);s&&typeof s.then=="function"&&s.catch(i=>{try{e.warn("callback failed",{...n??{},error:i,cb:r.name??""})}catch{}})}catch(s){try{e.warn("callback failed",{...n??{},error:s,cb:r.name??""})}catch{}}}const vr={error:0,warn:1,info:2,debug:3,trace:4};class ao{constructor(t="info"){this.minLevel=t}should(t){return vr[t]<=vr[this.minLevel]}method(t){switch(t){case"error":return console.error;case"warn":return console.warn;case"info":return console.info;case"debug":return console.debug;case"trace":return console.trace;default:return console.log}}header(t,e){return`[${t.toUpperCase()}] ${e}`}flattenContext(t){if(!t)return;const e={};for(const[n,s]of Object.entries(t))e[n]=s instanceof Error?{message:s.message,stack:s.stack}:s;return e}emit(t,e,n){if(!this.should(t))return;const s=this.header(t,e),i=this.flattenContext(n),o=this.method(t);i&&Object.keys(i).length?o(s,i):o(s)}error(t,e){this.emit("error",t,e)}warn(t,e){this.emit("warn",t,e)}info(t,e){this.emit("info",t,e)}debug(t,e){this.emit("debug",t,e)}trace(t,e){this.emit("trace",t,e)}log(t,e,n){this.emit(t,e,n)}}function uo(){const r=Date.now();return{elapsed:()=>Date.now()-r}}let kr={},_r=X;function lo(r){kr=r}function ho(r){_r=r}async function fo({endpoint:r,requestBody:t,headers:e,...n}){const s=t?JSON.stringify(t):void 0,i={Accept:"application/json, text/plain, */*",...s?{"Content-Type":"application/json"}:void 0,...e};let o;try{o=await fetch(r,{body:s,headers:i,...n})}catch(c){throw new mt(c instanceof Error?c.message:"Network request failed")}if(!o.ok){let c;try{c=await o.json()}catch{c={error:"bad response"}}if(o.status===400&&"code"in c&&typeof c.code=="number"&&"detail"in c&&typeof c.detail=="string")throw new we(c.code,c.detail);let a="HTTP request failed";throw"error"in c&&typeof c.error=="string"?a=c.error:"detail"in c&&typeof c.detail=="string"&&(a=c.detail),new rt(a,o.status)}try{return await o.json()}catch(c){throw _r.error("Failed to parse HTTP response",{err:c}),new rt("bad response",o.status)}}async function Ar(r){return await fo({...r,...kr})}let Ee;typeof WebSocket<"u"&&(Ee=WebSocket);function go(r){Ee=r}function po(){if(Ee===void 0)throw new Error("WebSocket implementation not initialized");return Ee}class N{static fromHex(t){if(t=t.trim(),t.length===0)return new Uint8Array(0);if(t.length<2||t.length&1)throw new Error("Invalid hex string: odd length.");if((t.startsWith("0x")||t.startsWith("0X"))&&(t=t.slice(2)),!t.match(/^[0-9a-fA-F]*$/))throw new Error("Invalid hex string: contains non-hex characters");const n=t.match(/.{1,2}/g);if(!n)throw new Error("Invalid hex string");return new Uint8Array(n.map(s=>parseInt(s,16)))}static toHex(t){return Array.from(t,e=>e.toString(16).padStart(2,"0")).join("")}static fromString(t){return t=t.trim(),new TextEncoder().encode(t)}static toString(t){return new TextDecoder("utf-8").decode(t)}static concat(...t){const e=t.reduce((i,o)=>i+o.length,0),n=new Uint8Array(e);let s=0;for(const i of t)n.set(i,s),s+=i.length;return n}static alloc(t){return new Uint8Array(t)}static writeBigUint64BE(t){const e=new ArrayBuffer(8);return new DataView(e).setBigUint64(0,t,!1),new Uint8Array(e)}static toBase64(t){if(typeof Buffer<"u")return Buffer.from(t).toString("base64");if(t.length>32768){let e="";for(let n=0;n<t.length;n+=32768){const s=t.slice(n,n+32768);e+=btoa(String.fromCharCode(...s))}return e}return btoa(String.fromCharCode(...t))}static fromBase64(t){t=t.trim();let e=t.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";return typeof Buffer<"u"?new Uint8Array(Buffer.from(e,"base64")):new Uint8Array([...atob(e)].map(n=>n.charCodeAt(0)))}static equals(t,e){if(t.length!==e.length)return!1;let n=0;for(let s=0;s<t.length;s++)n|=t[s]^e[s];return n===0}static compare(t,e){const n=Math.min(t.length,e.length);for(let s=0;s<n;s++){if(t[s]<e[s])return-1;if(t[s]>e[s])return 1}return t.length-e.length}static toBigInt(t){let e=0n;for(const n of t)e=e<<8n|BigInt(n);return e}static fromBigInt(t){if(t<0n)throw new RangeError("value must be non-negative");if(t===0n)return new Uint8Array([0]);let e=t,n=0;for(;e>0n;)n++,e>>=8n;const s=new Uint8Array(n);e=t;for(let i=n-1;i>=0;i--)s[i]=Number(e&0xffn),e>>=8n;return s}}function fn(r){return N.toBase64(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function dn(r){return N.fromBase64(r)}function Sr(r){const t=JSON.stringify(r);return wo(N.toBase64(N.fromString(t)))}function yo(r){const t=N.toString(N.fromBase64(mo(r)));return JSON.parse(t)}function mo(r){return r.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function wo(r){return r.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function ve(r){if(typeof r!="string"||r.length===0)return!1;const t=/^[A-Za-z0-9\-_]+={0,2}$/,e=/^[A-Za-z0-9+/]+={0,2}$/;if(!t.test(r)&&!e.test(r))return!1;const n=r.replace(/-/g,"+").replace(/_/g,"/"),s=(4-n.length%4)%4;if(s>2)return!1;const i=n+"=".repeat(s);try{const o=N.fromBase64(i),c=N.toBase64(o),a=c.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),u=n.replace(/=+$/,"");return c.replace(/=+$/,"")===u||a===u}catch{return!1}}/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Jt(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Pr(r,t){return Array.isArray(t)?t.length===0?!0:r?t.every(e=>typeof e=="string"):t.every(e=>Number.isSafeInteger(e)):!1}function xr(r){if(typeof r!="function")throw new Error("function expected");return!0}function te(r,t){if(typeof t!="string")throw new Error(`${r}: string expected`);return!0}function ee(r){if(!Number.isSafeInteger(r))throw new Error(`invalid integer: ${r}`)}function ke(r){if(!Array.isArray(r))throw new Error("array expected")}function Tr(r,t){if(!Pr(!0,t))throw new Error(`${r}: array of strings expected`)}function gn(r,t){if(!Pr(!1,t))throw new Error(`${r}: array of numbers expected`)}function pn(...r){const t=i=>i,e=(i,o)=>c=>i(o(c)),n=r.map(i=>i.encode).reduceRight(e,t),s=r.map(i=>i.decode).reduce(e,t);return{encode:n,decode:s}}function Ir(r){const t=typeof r=="string"?r.split(""):r,e=t.length;Tr("alphabet",t);const n=new Map(t.map((s,i)=>[s,i]));return{encode:s=>(ke(s),s.map(i=>{if(!Number.isSafeInteger(i)||i<0||i>=e)throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${r}`);return t[i]})),decode:s=>(ke(s),s.map(i=>{te("alphabet.decode",i);const o=n.get(i);if(o===void 0)throw new Error(`Unknown letter: "${i}". Allowed: ${r}`);return o}))}}function Br(r=""){return te("join",r),{encode:t=>(Tr("join.decode",t),t.join(r)),decode:t=>(te("join.decode",t),t.split(r))}}function Cr(r,t,e){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(e<2)throw new Error(`convertRadix: invalid to=${e}, base cannot be less than 2`);if(ke(r),!r.length)return[];let n=0;const s=[],i=Array.from(r,c=>{if(ee(c),c<0||c>=t)throw new Error(`invalid integer: ${c}`);return c}),o=i.length;for(;;){let c=0,a=!0;for(let u=n;u<o;u++){const l=i[u],h=t*c,f=h+l;if(!Number.isSafeInteger(f)||h/t!==c||f-l!==h)throw new Error("convertRadix: carry overflow");const d=f/e;c=f%e;const y=Math.floor(d);if(i[u]=y,!Number.isSafeInteger(y)||y*e+c!==f)throw new Error("convertRadix: carry overflow");if(a)y?a=!1:n=u;else continue}if(s.push(c),a)break}for(let c=0;c<r.length-1&&r[c]===0;c++)s.push(0);return s.reverse()}const Mr=(r,t)=>t===0?r:Mr(t,r%t),_e=(r,t)=>r+(t-Mr(r,t)),Ae=(()=>{let r=[];for(let t=0;t<40;t++)r.push(2**t);return r})();function yn(r,t,e,n){if(ke(r),t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(e<=0||e>32)throw new Error(`convertRadix2: wrong to=${e}`);if(_e(t,e)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${e} carryBits=${_e(t,e)}`);let s=0,i=0;const o=Ae[t],c=Ae[e]-1,a=[];for(const u of r){if(ee(u),u>=o)throw new Error(`convertRadix2: invalid data word=${u} from=${t}`);if(s=s<<t|u,i+t>32)throw new Error(`convertRadix2: carry overflow pos=${i} from=${t}`);for(i+=t;i>=e;i-=e)a.push((s>>i-e&c)>>>0);const l=Ae[i];if(l===void 0)throw new Error("invalid carry");s&=l-1}if(s=s<<e-i&c,!n&&i>=t)throw new Error("Excess padding");if(!n&&s>0)throw new Error(`Non-zero padding: ${s}`);return n&&i>0&&a.push(s>>>0),a}function bo(r){ee(r);const t=2**8;return{encode:e=>{if(!Jt(e))throw new Error("radix.encode input should be Uint8Array");return Cr(Array.from(e),t,r)},decode:e=>(gn("radix.decode",e),Uint8Array.from(Cr(e,r,t)))}}function Eo(r,t=!1){if(ee(r),r<=0||r>32)throw new Error("radix2: bits should be in (0..32]");if(_e(8,r)>32||_e(r,8)>32)throw new Error("radix2: carry overflow");return{encode:e=>{if(!Jt(e))throw new Error("radix2.encode input should be Uint8Array");return yn(Array.from(e),8,r,!t)},decode:e=>(gn("radix2.decode",e),Uint8Array.from(yn(e,r,8,t)))}}function Kr(r){return xr(r),function(...t){try{return r.apply(null,t)}catch{}}}function vo(r,t){return ee(r),xr(t),{encode(e){if(!Jt(e))throw new Error("checksum.encode: input should be Uint8Array");const n=t(e).slice(0,r),s=new Uint8Array(e.length+r);return s.set(e),s.set(n,e.length),s},decode(e){if(!Jt(e))throw new Error("checksum.decode: input should be Uint8Array");const n=e.slice(0,-r),s=e.slice(-r),i=t(n).slice(0,r);for(let o=0;o<r;o++)if(i[o]!==s[o])throw new Error("Invalid checksum");return n}}}const ko=(r=>pn(bo(58),Ir(r),Br("")))("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),_o=r=>pn(vo(4,t=>r(r(t))),ko),mn=pn(Ir("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),Br("")),Or=[996825010,642813549,513874426,1027748829,705979059];function ne(r){const t=r>>25;let e=(r&33554431)<<5;for(let n=0;n<Or.length;n++)(t>>n&1)===1&&(e^=Or[n]);return e}function Lr(r,t,e=1){const n=r.length;let s=1;for(let i=0;i<n;i++){const o=r.charCodeAt(i);if(o<33||o>126)throw new Error(`Invalid prefix (${r})`);s=ne(s)^o>>5}s=ne(s);for(let i=0;i<n;i++)s=ne(s)^r.charCodeAt(i)&31;for(let i of t)s=ne(s)^i;for(let i=0;i<6;i++)s=ne(s);return s^=e,mn.encode(yn([s%Ae[30]],30,5,!1))}function Rr(r){const t=r==="bech32"?1:734539939,e=Eo(5),n=e.decode,s=e.encode,i=Kr(n);function o(h,f,d=90){te("bech32.encode prefix",h),Jt(f)&&(f=Array.from(f)),gn("bech32.encode",f);const y=h.length;if(y===0)throw new TypeError(`Invalid prefix length ${y}`);const w=y+7+f.length;if(d!==!1&&w>d)throw new TypeError(`Length ${w} exceeds limit ${d}`);const b=h.toLowerCase(),P=Lr(b,f,t);return`${b}1${mn.encode(f)}${P}`}function c(h,f=90){te("bech32.decode input",h);const d=h.length;if(d<8||f!==!1&&d>f)throw new TypeError(`invalid string length: ${d} (${h}). Expected (8..${f})`);const y=h.toLowerCase();if(h!==y&&h!==h.toUpperCase())throw new Error("String must be lowercase or uppercase");const w=y.lastIndexOf("1");if(w===0||w===-1)throw new Error('Letter "1" must be present between prefix and data only');const b=y.slice(0,w),P=y.slice(w+1);if(P.length<6)throw new Error("Data must be at least 6 characters long");const K=mn.decode(P).slice(0,-6),B=Lr(b,K,t);if(!P.endsWith(B))throw new Error(`Invalid checksum in ${h}: expected "${B}"`);return{prefix:b,words:K}}const a=Kr(c);function u(h){const{prefix:f,words:d}=c(h,!1);return{prefix:f,words:d,bytes:n(d)}}function l(h,f){return o(h,s(f))}return{encode:o,decode:c,encodeFromBytes:l,decodeToBytes:u,decodeUnsafe:a,fromWords:n,fromWordsUnsafe:i,toWords:s}}const Se=Rr("bech32"),Pe=Rr("bech32m"),wn=1023;function Ao(r){const t=r.lastIndexOf("1");if(t<1||t===r.length-1)throw new Error("Invalid bech32m string: missing or misplaced separator")}function So(r,t,e=wn){const n=Pe.toWords(t);return Pe.encode(r,n,e)}function Po(r,t=wn){Ao(r);const{prefix:e,words:n}=Pe.decode(r,t),s=Pe.fromWords(n);return{hrp:e,data:s}}function xo(r,t=wn){return Po(r,t).data}function To(r){return typeof r=="number"||typeof r=="string"}function bn(r){const t=[];return En(r,t),new Uint8Array(t)}function En(r,t){if(r===null)t.push(246);else if(r===void 0)t.push(247);else if(typeof r=="boolean")t.push(r?245:244);else if(typeof r=="number")Mo(r,t);else if(typeof r=="string")Nr(r,t);else if(Array.isArray(r))Oo(r,t);else if(r instanceof Uint8Array)Ko(r,t);else if(typeof r=="object"&&r!==null&&!Array.isArray(r))Lo(r,t);else throw new Error("Unsupported type")}function Io(r,t){if(r<24)t.push(r);else if(r<256)t.push(24,r);else if(r<65536)t.push(25,r>>>8&255,r&255);else if(r<4294967296)t.push(26,r>>>24&255,r>>>16&255,r>>>8&255,r&255);else throw new Error("Unsupported integer size")}function Bo(r,t){const e=-1-r;if(e<24)t.push(32|e);else if(e<256)t.push(56,e&255);else if(e<65536)t.push(57,e>>>8&255,e&255);else if(e<4294967296)t.push(58,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Unsupported integer size")}function Co(r,t){const e=new ArrayBuffer(8),n=new DataView(e);n.setFloat64(0,r,!1),t.push(251);for(let s=0;s<8;s++)t.push(n.getUint8(s))}function Mo(r,t){Number.isInteger(r)?r>=0?Io(r,t):Bo(r,t):Co(r,t)}function Ko(r,t){const e=r.length;if(e<24)t.push(64+e);else if(e<256)t.push(88,e);else if(e<65536)t.push(89,e>>8&255,e&255);else if(e<4294967296)t.push(90,e>>>24&255,e>>>16&255,e>>>8&255,e&255);else throw new Error("Byte string too long to encode");for(let n=0;n<r.length;n++)t.push(r[n])}function Nr(r,t){const e=new TextEncoder().encode(r),n=e.length;if(n<24)t.push(96+n);else if(n<256)t.push(120,n);else if(n<65536)t.push(121,n>>>8&255,n&255);else if(n<4294967296)t.push(122,n>>>24&255,n>>>16&255,n>>>8&255,n&255);else throw new Error("String too long to encode");for(let s=0;s<e.length;s++)t.push(e[s])}function Oo(r,t){const e=r.length;if(e<24)t.push(128|e);else if(e<256)t.push(152,e);else if(e<65536)t.push(153,e>>>8&255,e&255);else throw new Error("Unsupported array length");for(const n of r)En(n,t)}function Lo(r,t){const e=Object.keys(r),n=e.length;if(n>=4294967296)throw new Error("Object has too many keys to encode");n<24?t.push(160|n):n<256?t.push(184,n):n<65536?t.push(185,n>>8&255,n&255):t.push(186,n>>24&255,n>>16&255,n>>8&255,n&255);for(const s of e)Nr(s,t),En(r[s],t)}function vn(r){const t=new DataView(r.buffer,r.byteOffset,r.byteLength);return xe(t,0).value}function xe(r,t){if(t>=r.byteLength)throw new Error("Unexpected end of data");const e=r.getUint8(t++),n=e>>5,s=e&31;switch(n){case 0:return Ro(r,t,s);case 1:return No(r,t,s);case 2:return Uo(r,t,s);case 3:return Do(r,t,s);case 4:return qo(r,t,s);case 5:return Fo(r,t,s);case 7:return $o(r,t,s);default:throw new Error(`Unsupported major type: ${n}`)}}function _t(r,t,e){if(t+e>r.byteLength)throw new Error("Unexpected end of data")}function qt(r,t,e){if(e<24)return{value:e,offset:t};if(e===24)return _t(r,t,1),{value:r.getUint8(t++),offset:t};if(e===25){_t(r,t,2);const n=r.getUint16(t,!1);return t+=2,{value:n,offset:t}}if(e===26){_t(r,t,4);const n=r.getUint32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){_t(r,t,8);const n=r.getUint32(t,!1),s=r.getUint32(t+4,!1);return t+=8,{value:n*4294967296+s,offset:t}}throw new Error(`Unsupported length: ${e}`)}function Ro(r,t,e){const{value:n,offset:s}=qt(r,t,e);return{value:n,offset:s}}function No(r,t,e){const{value:n,offset:s}=qt(r,t,e);return{value:-1-n,offset:s}}function Uo(r,t,e){const{value:n,offset:s}=qt(r,t,e);if(s+n>r.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(r.buffer,r.byteOffset+s,n),offset:s+n}}function Do(r,t,e){const{value:n,offset:s}=qt(r,t,e);if(s+n>r.byteLength)throw new Error("String length exceeds data length");const i=new Uint8Array(r.buffer,r.byteOffset+s,n);return{value:new TextDecoder().decode(i),offset:s+n}}function qo(r,t,e){const{value:n,offset:s}=qt(r,t,e),i=[];let o=s;for(let c=0;c<n;c++){const a=xe(r,o);i.push(a.value),o=a.offset}return{value:i,offset:o}}function Fo(r,t,e){const{value:n,offset:s}=qt(r,t,e),i={};let o=s;for(let c=0;c<n;c++){const a=xe(r,o);if(!To(a.value))throw new Error("Invalid key type");const u=xe(r,a.offset);i[a.value]=u.value,o=u.offset}return{value:i,offset:o}}function Ho(r){const t=(r&31744)>>10,e=r&1023,n=r&32768?-1:1;return t===0?n*6103515625e-14*(e/1024):t===31?e?NaN:n*(1/0):n*2**(t-15)*(1+e/1024)}function $o(r,t,e){if(e<24)switch(e){case 20:return{value:!1,offset:t};case 21:return{value:!0,offset:t};case 22:return{value:null,offset:t};case 23:return{value:void 0,offset:t};default:throw new Error(`Unknown simple value: ${e}`)}if(e===24)return _t(r,t,1),{value:r.getUint8(t++),offset:t};if(e===25){_t(r,t,2);const n=Ho(r.getUint16(t,!1));return t+=2,{value:n,offset:t}}if(e===26){_t(r,t,4);const n=r.getFloat32(t,!1);return t+=4,{value:n,offset:t}}if(e===27){_t(r,t,8);const n=r.getFloat64(t,!1);return t+=8,{value:n,offset:t}}throw new Error(`Unknown simple or float value: ${e}`)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function kn(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Mt(r,t=""){if(!Number.isSafeInteger(r)||r<0){const e=t&&`"${t}" `;throw new Error(`${e}expected integer >= 0, got ${r}`)}}function D(r,t,e=""){const n=kn(r),s=r?.length,i=t!==void 0;if(!n||i&&s!==t){const o=e&&`"${e}" `,c=i?` of length ${t}`:"",a=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+c+", got "+a)}return r}function Ur(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Mt(r.outputLen),Mt(r.blockLen)}function Te(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Wo(r,t){D(r,void 0,"digestInto() output");const e=t.outputLen;if(r.length<e)throw new Error('"digestInto() output" expected to be of length >='+e)}function At(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function Ft(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function pt(r,t){return r<<32-t|r>>>t}function Ie(r,t){return r<<t|r>>>32-t>>>0}const Dr=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",jo=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function H(r){if(D(r),Dr)return r.toHex();let t="";for(let e=0;e<r.length;e++)t+=jo[r[e]];return t}const wt={_0:48,_9:57,A:65,F:70,a:97,f:102};function qr(r){if(r>=wt._0&&r<=wt._9)return r-wt._0;if(r>=wt.A&&r<=wt.F)return r-(wt.A-10);if(r>=wt.a&&r<=wt.f)return r-(wt.a-10)}function U(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(Dr)return Uint8Array.fromHex(r);const t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const o=qr(r.charCodeAt(i)),c=qr(r.charCodeAt(i+1));if(o===void 0||c===void 0){const a=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+i)}n[s]=o*16+c}return n}function Fr(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function st(...r){let t=0;for(let n=0;n<r.length;n++){const s=r[n];D(s),t+=s.length}const e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){const i=r[n];e.set(i,s),s+=i.length}return e}function _n(r,t={}){const e=(s,i)=>r(i).update(s).digest(),n=r(void 0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=s=>r(s),Object.assign(e,t),Object.freeze(e)}function yt(r=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(r))}const Hr=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function Vo(r,t,e){return r&t^~r&e}function Go(r,t,e){return r&t^r&e^t&e}class An{constructor(t,e,n,s){k(this,"blockLen");k(this,"outputLen");k(this,"padOffset");k(this,"isLE");k(this,"buffer");k(this,"view");k(this,"finished",!1);k(this,"length",0);k(this,"pos",0);k(this,"destroyed",!1);this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(t),this.view=Ft(this.buffer)}update(t){Te(this),D(t);const{view:e,buffer:n,blockLen:s}=this,i=t.length;for(let o=0;o<i;){const c=Math.min(s-this.pos,i-o);if(c===s){const a=Ft(t);for(;s<=i-o;o+=s)this.process(a,o);continue}n.set(t.subarray(o,o+c),this.pos),this.pos+=c,o+=c,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Te(this),Wo(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;e[o++]=128,At(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let h=o;h<s;h++)e[h]=0;n.setBigUint64(s-8,BigInt(this.length*8),i),this.process(n,0);const c=Ft(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=a/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)c.setUint32(4*h,l[h],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:s,finished:i,destroyed:o,pos:c}=this;return t.destroyed=o,t.finished=i,t.length=s,t.pos=c,s%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const St=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),J=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Be=BigInt(2**32-1),$r=BigInt(32);function zo(r,t=!1){return t?{h:Number(r&Be),l:Number(r>>$r&Be)}:{h:Number(r>>$r&Be)|0,l:Number(r&Be)|0}}function Qo(r,t=!1){const e=r.length;let n=new Uint32Array(e),s=new Uint32Array(e);for(let i=0;i<e;i++){const{h:o,l:c}=zo(r[i],t);[n[i],s[i]]=[o,c]}return[n,s]}const Wr=(r,t,e)=>r>>>e,jr=(r,t,e)=>r<<32-e|t>>>e,Ht=(r,t,e)=>r>>>e|t<<32-e,$t=(r,t,e)=>r<<32-e|t>>>e,Ce=(r,t,e)=>r<<64-e|t>>>e-32,Me=(r,t,e)=>r>>>e-32|t<<64-e;function bt(r,t,e,n){const s=(t>>>0)+(n>>>0);return{h:r+e+(s/4294967296|0)|0,l:s|0}}const Zo=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Yo=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Xo=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Jo=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,tc=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),ec=(r,t,e,n,s,i)=>t+e+n+s+i+(r/2**32|0)|0,nc=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Pt=new Uint32Array(64);class rc extends An{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:e,C:n,D:s,E:i,F:o,G:c,H:a}=this;return[t,e,n,s,i,o,c,a]}set(t,e,n,s,i,o,c,a){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=c|0,this.H=a|0}process(t,e){for(let h=0;h<16;h++,e+=4)Pt[h]=t.getUint32(e,!1);for(let h=16;h<64;h++){const f=Pt[h-15],d=Pt[h-2],y=pt(f,7)^pt(f,18)^f>>>3,w=pt(d,17)^pt(d,19)^d>>>10;Pt[h]=w+Pt[h-7]+y+Pt[h-16]|0}let{A:n,B:s,C:i,D:o,E:c,F:a,G:u,H:l}=this;for(let h=0;h<64;h++){const f=pt(c,6)^pt(c,11)^pt(c,25),d=l+f+Vo(c,a,u)+nc[h]+Pt[h]|0,w=(pt(n,2)^pt(n,13)^pt(n,22))+Go(n,s,i)|0;l=u,u=a,a=c,c=o+d|0,o=i,i=s,s=n,n=d+w|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,c=c+this.E|0,a=a+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,s,i,o,c,a,u,l)}roundClean(){At(Pt)}destroy(){this.set(0,0,0,0,0,0,0,0),At(this.buffer)}}class sc extends rc{constructor(){super(32);k(this,"A",St[0]|0);k(this,"B",St[1]|0);k(this,"C",St[2]|0);k(this,"D",St[3]|0);k(this,"E",St[4]|0);k(this,"F",St[5]|0);k(this,"G",St[6]|0);k(this,"H",St[7]|0)}}const Vr=Qo(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),ic=Vr[0],oc=Vr[1],xt=new Uint32Array(80),Tt=new Uint32Array(80);class cc extends An{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:e,Bh:n,Bl:s,Ch:i,Cl:o,Dh:c,Dl:a,Eh:u,El:l,Fh:h,Fl:f,Gh:d,Gl:y,Hh:w,Hl:b}=this;return[t,e,n,s,i,o,c,a,u,l,h,f,d,y,w,b]}set(t,e,n,s,i,o,c,a,u,l,h,f,d,y,w,b){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=c|0,this.Dl=a|0,this.Eh=u|0,this.El=l|0,this.Fh=h|0,this.Fl=f|0,this.Gh=d|0,this.Gl=y|0,this.Hh=w|0,this.Hl=b|0}process(t,e){for(let B=0;B<16;B++,e+=4)xt[B]=t.getUint32(e),Tt[B]=t.getUint32(e+=4);for(let B=16;B<80;B++){const q=xt[B-15]|0,V=Tt[B-15]|0,F=Ht(q,V,1)^Ht(q,V,8)^Wr(q,V,7),Y=$t(q,V,1)^$t(q,V,8)^jr(q,V,7),$=xt[B-2]|0,L=Tt[B-2]|0,ft=Ht($,L,19)^Ce($,L,61)^Wr($,L,6),at=$t($,L,19)^Me($,L,61)^jr($,L,6),_=Xo(Y,at,Tt[B-7],Tt[B-16]),E=Jo(_,F,ft,xt[B-7],xt[B-16]);xt[B]=E|0,Tt[B]=_|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:c,Cl:a,Dh:u,Dl:l,Eh:h,El:f,Fh:d,Fl:y,Gh:w,Gl:b,Hh:P,Hl:K}=this;for(let B=0;B<80;B++){const q=Ht(h,f,14)^Ht(h,f,18)^Ce(h,f,41),V=$t(h,f,14)^$t(h,f,18)^Me(h,f,41),F=h&d^~h&w,Y=f&y^~f&b,$=tc(K,V,Y,oc[B],Tt[B]),L=ec($,P,q,F,ic[B],xt[B]),ft=$|0,at=Ht(n,s,28)^Ce(n,s,34)^Ce(n,s,39),_=$t(n,s,28)^Me(n,s,34)^Me(n,s,39),E=n&i^n&c^i&c,m=s&o^s&a^o&a;P=w|0,K=b|0,w=d|0,b=y|0,d=h|0,y=f|0,{h,l:f}=bt(u|0,l|0,L|0,ft|0),u=c|0,l=a|0,c=i|0,a=o|0,i=n|0,o=s|0;const p=Zo(ft,_,m);n=Yo(p,L,at,E),s=p|0}({h:n,l:s}=bt(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=bt(this.Bh|0,this.Bl|0,i|0,o|0),{h:c,l:a}=bt(this.Ch|0,this.Cl|0,c|0,a|0),{h:u,l}=bt(this.Dh|0,this.Dl|0,u|0,l|0),{h,l:f}=bt(this.Eh|0,this.El|0,h|0,f|0),{h:d,l:y}=bt(this.Fh|0,this.Fl|0,d|0,y|0),{h:w,l:b}=bt(this.Gh|0,this.Gl|0,w|0,b|0),{h:P,l:K}=bt(this.Hh|0,this.Hl|0,P|0,K|0),this.set(n,s,i,o,c,a,u,l,h,f,d,y,w,b,P,K)}roundClean(){At(xt,Tt)}destroy(){At(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class ac extends cc{constructor(){super(64);k(this,"Ah",J[0]|0);k(this,"Al",J[1]|0);k(this,"Bh",J[2]|0);k(this,"Bl",J[3]|0);k(this,"Ch",J[4]|0);k(this,"Cl",J[5]|0);k(this,"Dh",J[6]|0);k(this,"Dl",J[7]|0);k(this,"Eh",J[8]|0);k(this,"El",J[9]|0);k(this,"Fh",J[10]|0);k(this,"Fl",J[11]|0);k(this,"Gh",J[12]|0);k(this,"Gl",J[13]|0);k(this,"Hh",J[14]|0);k(this,"Hl",J[15]|0)}}const Z=_n(()=>new sc,Hr(1)),Gr=_n(()=>new ac,Hr(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Sn=BigInt(0),Pn=BigInt(1);function Ke(r,t=""){if(typeof r!="boolean"){const e=t&&`"${t}" `;throw new Error(e+"expected boolean, got type="+typeof r)}return r}function zr(r){if(typeof r=="bigint"){if(!Re(r))throw new Error("positive bigint expected, got "+r)}else Mt(r);return r}function Oe(r){const t=zr(r).toString(16);return t.length&1?"0"+t:t}function Qr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Sn:BigInt("0x"+r)}function re(r){return Qr(H(r))}function Zr(r){return Qr(H(uc(D(r)).reverse()))}function Le(r,t){Mt(t),r=zr(r);const e=U(r.toString(16).padStart(t*2,"0"));if(e.length!==t)throw new Error("number too large");return e}function Yr(r,t){return Le(r,t).reverse()}function uc(r){return Uint8Array.from(r)}function lc(r){return Uint8Array.from(r,(t,e)=>{const n=t.charCodeAt(0);if(t.length!==1||n>127)throw new Error(`string contains non-ASCII character "${r[e]}" with code ${n} at position ${e}`);return n})}const Re=r=>typeof r=="bigint"&&Sn<=r;function hc(r,t,e){return Re(r)&&Re(t)&&Re(e)&&t<=r&&r<e}function fc(r,t,e,n){if(!hc(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function dc(r){let t;for(t=0;r>Sn;r>>=Pn,t+=1);return t}const xn=r=>(Pn<<BigInt(r))-Pn;function gc(r,t,e){if(Mt(r,"hashLen"),Mt(t,"qByteLen"),typeof e!="function")throw new Error("hmacFn must be a function");const n=b=>new Uint8Array(b),s=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),c=1e3;let a=n(r),u=n(r),l=0;const h=()=>{a.fill(1),u.fill(0),l=0},f=(...b)=>e(u,st(a,...b)),d=(b=s)=>{u=f(i,b),a=f(),b.length!==0&&(u=f(o,b),a=f())},y=()=>{if(l++>=c)throw new Error("drbg: tried max amount of iterations");let b=0;const P=[];for(;b<t;){a=f();const K=a.slice();P.push(K),b+=a.length}return st(...P)};return(b,P)=>{h(),d(b);let K;for(;!(K=P(y()));)d();return h(),K}}function Tn(r,t={},e={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(i,o,c){const a=r[i];if(c&&a===void 0)return;const u=typeof a;if(u!==o||a===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${u}`)}const s=(i,o)=>Object.entries(i).forEach(([c,a])=>n(c,a,o));s(t,!1),s(e,!0)}function Xr(r){const t=new WeakMap;return(e,...n)=>{const s=t.get(e);if(s!==void 0)return s;const i=r(e,...n);return t.set(e,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const it=BigInt(0),tt=BigInt(1),Kt=BigInt(2),Jr=BigInt(3),ts=BigInt(4),es=BigInt(5),pc=BigInt(7),ns=BigInt(8),yc=BigInt(9),rs=BigInt(16);function dt(r,t){const e=r%t;return e>=it?e:t+e}function lt(r,t,e){let n=r;for(;t-- >it;)n*=n,n%=e;return n}function ss(r,t){if(r===it)throw new Error("invert: expected non-zero number");if(t<=it)throw new Error("invert: expected positive modulus, got "+t);let e=dt(r,t),n=t,s=it,i=tt;for(;e!==it;){const c=n/e,a=n%e,u=s-i*c;n=e,e=a,s=i,i=u}if(n!==tt)throw new Error("invert: does not exist");return dt(s,t)}function In(r,t,e){if(!r.eql(r.sqr(t),e))throw new Error("Cannot find square root")}function is(r,t){const e=(r.ORDER+tt)/ts,n=r.pow(t,e);return In(r,n,t),n}function mc(r,t){const e=(r.ORDER-es)/ns,n=r.mul(t,Kt),s=r.pow(n,e),i=r.mul(t,s),o=r.mul(r.mul(i,Kt),s),c=r.mul(i,r.sub(o,r.ONE));return In(r,c,t),c}function wc(r){const t=Ne(r),e=os(r),n=e(t,t.neg(t.ONE)),s=e(t,n),i=e(t,t.neg(n)),o=(r+pc)/rs;return(c,a)=>{let u=c.pow(a,o),l=c.mul(u,n);const h=c.mul(u,s),f=c.mul(u,i),d=c.eql(c.sqr(l),a),y=c.eql(c.sqr(h),a);u=c.cmov(u,l,d),l=c.cmov(f,h,y);const w=c.eql(c.sqr(l),a),b=c.cmov(u,l,w);return In(c,b,a),b}}function os(r){if(r<Jr)throw new Error("sqrt is not defined for small field");let t=r-tt,e=0;for(;t%Kt===it;)t/=Kt,e++;let n=Kt;const s=Ne(r);for(;as(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return is;let i=s.pow(n,t);const o=(t+tt)/Kt;return function(a,u){if(a.is0(u))return u;if(as(a,u)!==1)throw new Error("Cannot find square root");let l=e,h=a.mul(a.ONE,i),f=a.pow(u,t),d=a.pow(u,o);for(;!a.eql(f,a.ONE);){if(a.is0(f))return a.ZERO;let y=1,w=a.sqr(f);for(;!a.eql(w,a.ONE);)if(y++,w=a.sqr(w),y===l)throw new Error("Cannot find square root");const b=tt<<BigInt(l-y-1),P=a.pow(h,b);l=y,h=a.sqr(P),f=a.mul(f,h),d=a.mul(d,P)}return d}}function bc(r){return r%ts===Jr?is:r%ns===es?mc:r%rs===yc?wc(r):os(r)}const Ec=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function vc(r){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},e=Ec.reduce((n,s)=>(n[s]="function",n),t);return Tn(r,e),r}function kc(r,t,e){if(e<it)throw new Error("invalid exponent, negatives unsupported");if(e===it)return r.ONE;if(e===tt)return t;let n=r.ONE,s=t;for(;e>it;)e&tt&&(n=r.mul(n,s)),s=r.sqr(s),e>>=tt;return n}function cs(r,t,e=!1){const n=new Array(t.length).fill(e?r.ZERO:void 0),s=t.reduce((o,c,a)=>r.is0(c)?o:(n[a]=o,r.mul(o,c)),r.ONE),i=r.inv(s);return t.reduceRight((o,c,a)=>r.is0(c)?o:(n[a]=r.mul(o,n[a]),r.mul(o,c)),i),n}function as(r,t){const e=(r.ORDER-tt)/Kt,n=r.pow(t,e),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function _c(r,t){t!==void 0&&Mt(t);const e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}class Ac{constructor(t,e={}){k(this,"ORDER");k(this,"BITS");k(this,"BYTES");k(this,"isLE");k(this,"ZERO",it);k(this,"ONE",tt);k(this,"_lengths");k(this,"_sqrt");k(this,"_mod");if(t<=it)throw new Error("invalid field: expected ORDER > 0, got "+t);let n;this.isLE=!1,e!=null&&typeof e=="object"&&(typeof e.BITS=="number"&&(n=e.BITS),typeof e.sqrt=="function"&&(this.sqrt=e.sqrt),typeof e.isLE=="boolean"&&(this.isLE=e.isLE),e.allowedLengths&&(this._lengths=e.allowedLengths?.slice()),typeof e.modFromBytes=="boolean"&&(this._mod=e.modFromBytes));const{nBitLength:s,nByteLength:i}=_c(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return dt(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return it<=t&&t<this.ORDER}is0(t){return t===it}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&tt)===tt}neg(t){return dt(-t,this.ORDER)}eql(t,e){return t===e}sqr(t){return dt(t*t,this.ORDER)}add(t,e){return dt(t+e,this.ORDER)}sub(t,e){return dt(t-e,this.ORDER)}mul(t,e){return dt(t*e,this.ORDER)}pow(t,e){return kc(this,t,e)}div(t,e){return dt(t*ss(e,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,e){return t+e}subN(t,e){return t-e}mulN(t,e){return t*e}inv(t){return ss(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=bc(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Yr(t,this.BYTES):Le(t,this.BYTES)}fromBytes(t,e=!1){D(t);const{_lengths:n,BYTES:s,isLE:i,ORDER:o,_mod:c}=this;if(n){if(!n.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+t.length);const u=new Uint8Array(s);u.set(t,i?0:u.length-t.length),t=u}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let a=i?Zr(t):re(t);if(c&&(a=dt(a,o)),!e&&!this.isValid(a))throw new Error("invalid field element: outside of range 0..ORDER");return a}invertBatch(t){return cs(this,t)}cmov(t,e,n){return n?e:t}}function Ne(r,t={}){return new Ac(r,t)}function us(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const t=r.toString(2).length;return Math.ceil(t/8)}function ls(r){const t=us(r);return t+Math.ceil(t/2)}function hs(r,t,e=!1){D(r);const n=r.length,s=us(t),i=ls(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=e?Zr(r):re(r),c=dt(o,t-tt)+tt;return e?Yr(c,s):Le(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Wt=BigInt(0),Ot=BigInt(1);function Ue(r,t){const e=t.negate();return r?e:t}function fs(r,t){const e=cs(r.Fp,t.map(n=>n.Z));return t.map((n,s)=>r.fromAffine(n.toAffine(e[s])))}function ds(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function Bn(r,t){ds(r,t);const e=Math.ceil(t/r)+1,n=2**(r-1),s=2**r,i=xn(r),o=BigInt(r);return{windows:e,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function gs(r,t,e){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=e;let c=Number(r&s),a=r>>o;c>n&&(c-=i,a+=Ot);const u=t*n,l=u+Math.abs(c)-1,h=c===0,f=c<0,d=t%2!==0;return{nextN:a,offset:l,isZero:h,isNeg:f,isNegF:d,offsetF:u}}const Cn=new WeakMap,ps=new WeakMap;function Mn(r){return ps.get(r)||1}function ys(r){if(r!==Wt)throw new Error("invalid wNAF")}class Sc{constructor(t,e){k(this,"BASE");k(this,"ZERO");k(this,"Fn");k(this,"bits");this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let s=t;for(;e>Wt;)e&Ot&&(n=n.add(s)),s=s.double(),e>>=Ot;return n}precomputeWindow(t,e){const{windows:n,windowSize:s}=Bn(e,this.bits),i=[];let o=t,c=o;for(let a=0;a<n;a++){c=o,i.push(c);for(let u=1;u<s;u++)c=c.add(o),i.push(c);o=c.double()}return i}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=Bn(t,this.bits);for(let c=0;c<o.windows;c++){const{nextN:a,offset:u,isZero:l,isNeg:h,isNegF:f,offsetF:d}=gs(n,c,o);n=a,l?i=i.add(Ue(f,e[d])):s=s.add(Ue(h,e[u]))}return ys(n),{p:s,f:i}}wNAFUnsafe(t,e,n,s=this.ZERO){const i=Bn(t,this.bits);for(let o=0;o<i.windows&&n!==Wt;o++){const{nextN:c,offset:a,isZero:u,isNeg:l}=gs(n,o,i);if(n=c,!u){const h=e[a];s=s.add(l?h.negate():h)}}return ys(n),s}getPrecomputes(t,e,n){let s=Cn.get(e);return s||(s=this.precomputeWindow(e,t),t!==1&&(typeof n=="function"&&(s=n(s)),Cn.set(e,s))),s}cached(t,e,n){const s=Mn(t);return this.wNAF(s,this.getPrecomputes(s,t,n),e)}unsafe(t,e,n,s){const i=Mn(t);return i===1?this._unsafeLadder(t,e,s):this.wNAFUnsafe(i,this.getPrecomputes(i,t,n),e,s)}createCache(t,e){ds(e,this.bits),ps.set(t,e),Cn.delete(t)}hasCache(t){return Mn(t)!==1}}function Pc(r,t,e,n){let s=t,i=r.ZERO,o=r.ZERO;for(;e>Wt||n>Wt;)e&Ot&&(i=i.add(s)),n&Ot&&(o=o.add(s)),s=s.double(),e>>=Ot,n>>=Ot;return{p1:i,p2:o}}function ms(r,t,e){if(t){if(t.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return vc(t),t}else return Ne(r,{isLE:e})}function xc(r,t,e={},n){if(n===void 0&&(n=r==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${r} CURVE object`);for(const a of["p","n","h"]){const u=t[a];if(!(typeof u=="bigint"&&u>Wt))throw new Error(`CURVE.${a} must be positive bigint`)}const s=ms(t.p,e.Fp,n),i=ms(t.n,e.Fn,n),c=["Gx","Gy","a","b"];for(const a of c)if(!s.isValid(t[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:i}}function ws(r,t){return function(n){const s=r(n);return{secretKey:s,publicKey:t(s)}}}class bs{constructor(t,e){k(this,"oHash");k(this,"iHash");k(this,"blockLen");k(this,"outputLen");k(this,"finished",!1);k(this,"destroyed",!1);if(Ur(t),D(e,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(e.length>n?t.create().update(e).digest():e);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),At(s)}update(t){return Te(this),this.iHash.update(t),this}digestInto(t){Te(this),D(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:c}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=c,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const se=(r,t,e)=>new bs(r,t).update(e).digest();se.create=(r,t)=>new bs(r,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Es=(r,t)=>(r+(r>=0?t:-t)/vs)/t;function Tc(r,t,e){const[[n,s],[i,o]]=t,c=Es(o*r,e),a=Es(-s*r,e);let u=r-c*n-a*i,l=-c*s-a*o;const h=u<Et,f=l<Et;h&&(u=-u),f&&(l=-l);const d=xn(Math.ceil(dc(e)/2))+jt;if(u<Et||u>=d||l<Et||l>=d)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:h,k1:u,k2neg:f,k2:l}}function Kn(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function On(r,t){const e={};for(let n of Object.keys(t))e[n]=r[n]===void 0?t[n]:r[n];return Ke(e.lowS,"lowS"),Ke(e.prehash,"prehash"),e.format!==void 0&&Kn(e.format),e}class Ic extends Error{constructor(t=""){super(t)}}const It={Err:Ic,_tlv:{encode:(r,t)=>{const{Err:e}=It;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const n=t.length/2,s=Oe(n);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=n>127?Oe(s.length/2|128):"";return Oe(r)+i+s+t},decode(r,t){const{Err:e}=It;let n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");const s=t[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const a=s&127;if(!a)throw new e("tlv.decode(long): indefinite length not supported");if(a>4)throw new e("tlv.decode(long): byte length is too big");const u=t.subarray(n,n+a);if(u.length!==a)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const l of u)o=o<<8|l;if(n+=a,o<128)throw new e("tlv.decode(long): not minimal encoding")}const c=t.subarray(n,n+o);if(c.length!==o)throw new e("tlv.decode: wrong value length");return{v:c,l:t.subarray(n+o)}}},_int:{encode(r){const{Err:t}=It;if(r<Et)throw new t("integer: negative integers are not allowed");let e=Oe(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){const{Err:t}=It;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return re(r)}},toSig(r){const{Err:t,_int:e,_tlv:n}=It,s=D(r,void 0,"signature"),{v:i,l:o}=n.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:a}=n.decode(2,i),{v:u,l}=n.decode(2,a);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(c),s:e.decode(u)}},hexFromSig(r){const{_tlv:t,_int:e}=It,n=t.encode(2,e.encode(r.r)),s=t.encode(2,e.encode(r.s)),i=n+s;return t.encode(48,i)}},Et=BigInt(0),jt=BigInt(1),vs=BigInt(2),De=BigInt(3),Bc=BigInt(4);function Cc(r,t={}){const e=xc("weierstrass",r,t),{Fp:n,Fn:s}=e;let i=e.CURVE;const{h:o,n:c}=i;Tn(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:a}=t;if(a&&(!n.is0(i.a)||typeof a.beta!="bigint"||!Array.isArray(a.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=_s(n,s);function l(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(E,m,p){const{x:v,y:S}=m.toAffine(),C=n.toBytes(v);if(Ke(p,"isCompressed"),p){l();const I=!n.isOdd(S);return st(ks(I),C)}else return st(Uint8Array.of(4),C,n.toBytes(S))}function f(E){D(E,void 0,"Point");const{publicKey:m,publicKeyUncompressed:p}=u,v=E.length,S=E[0],C=E.subarray(1);if(v===m&&(S===2||S===3)){const I=n.fromBytes(C);if(!n.isValid(I))throw new Error("bad point: is not on curve, wrong x");const x=w(I);let A;try{A=n.sqrt(x)}catch(j){const W=j instanceof Error?": "+j.message:"";throw new Error("bad point: is not on curve, sqrt error"+W)}l();const T=n.isOdd(A);return(S&1)===1!==T&&(A=n.neg(A)),{x:I,y:A}}else if(v===p&&S===4){const I=n.BYTES,x=n.fromBytes(C.subarray(0,I)),A=n.fromBytes(C.subarray(I,I*2));if(!b(x,A))throw new Error("bad point: is not on curve");return{x,y:A}}else throw new Error(`bad point: got length ${v}, expected compressed=${m} or uncompressed=${p}`)}const d=t.toBytes||h,y=t.fromBytes||f;function w(E){const m=n.sqr(E),p=n.mul(m,E);return n.add(n.add(p,n.mul(E,i.a)),i.b)}function b(E,m){const p=n.sqr(m),v=w(E);return n.eql(p,v)}if(!b(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const P=n.mul(n.pow(i.a,De),Bc),K=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(P,K)))throw new Error("bad curve params: a or b");function B(E,m,p=!1){if(!n.isValid(m)||p&&n.is0(m))throw new Error(`bad point coordinate ${E}`);return m}function q(E){if(!(E instanceof L))throw new Error("Weierstrass Point expected")}function V(E){if(!a||!a.basises)throw new Error("no endo");return Tc(E,a.basises,s.ORDER)}const F=Xr((E,m)=>{const{X:p,Y:v,Z:S}=E;if(n.eql(S,n.ONE))return{x:p,y:v};const C=E.is0();m==null&&(m=C?n.ONE:n.inv(S));const I=n.mul(p,m),x=n.mul(v,m),A=n.mul(S,m);if(C)return{x:n.ZERO,y:n.ZERO};if(!n.eql(A,n.ONE))throw new Error("invZ was invalid");return{x:I,y:x}}),Y=Xr(E=>{if(E.is0()){if(t.allowInfinityPoint&&!n.is0(E.Y))return;throw new Error("bad point: ZERO")}const{x:m,y:p}=E.toAffine();if(!n.isValid(m)||!n.isValid(p))throw new Error("bad point: x or y not field elements");if(!b(m,p))throw new Error("bad point: equation left != right");if(!E.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function $(E,m,p,v,S){return p=new L(n.mul(p.X,E),p.Y,p.Z),m=Ue(v,m),p=Ue(S,p),m.add(p)}const _=class _{constructor(m,p,v){k(this,"X");k(this,"Y");k(this,"Z");this.X=B("x",m),this.Y=B("y",p,!0),this.Z=B("z",v),Object.freeze(this)}static CURVE(){return i}static fromAffine(m){const{x:p,y:v}=m||{};if(!m||!n.isValid(p)||!n.isValid(v))throw new Error("invalid affine point");if(m instanceof _)throw new Error("projective point not allowed");return n.is0(p)&&n.is0(v)?_.ZERO:new _(p,v,n.ONE)}static fromBytes(m){const p=_.fromAffine(y(D(m,void 0,"point")));return p.assertValidity(),p}static fromHex(m){return _.fromBytes(U(m))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(m=8,p=!0){return at.createCache(this,m),p||this.multiply(De),this}assertValidity(){Y(this)}hasEvenY(){const{y:m}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(m)}equals(m){q(m);const{X:p,Y:v,Z:S}=this,{X:C,Y:I,Z:x}=m,A=n.eql(n.mul(p,x),n.mul(C,S)),T=n.eql(n.mul(v,x),n.mul(I,S));return A&&T}negate(){return new _(this.X,n.neg(this.Y),this.Z)}double(){const{a:m,b:p}=i,v=n.mul(p,De),{X:S,Y:C,Z:I}=this;let x=n.ZERO,A=n.ZERO,T=n.ZERO,M=n.mul(S,S),j=n.mul(C,C),W=n.mul(I,I),R=n.mul(S,C);return R=n.add(R,R),T=n.mul(S,I),T=n.add(T,T),x=n.mul(m,T),A=n.mul(v,W),A=n.add(x,A),x=n.sub(j,A),A=n.add(j,A),A=n.mul(x,A),x=n.mul(R,x),T=n.mul(v,T),W=n.mul(m,W),R=n.sub(M,W),R=n.mul(m,R),R=n.add(R,T),T=n.add(M,M),M=n.add(T,M),M=n.add(M,W),M=n.mul(M,R),A=n.add(A,M),W=n.mul(C,I),W=n.add(W,W),M=n.mul(W,R),x=n.sub(x,M),T=n.mul(W,j),T=n.add(T,T),T=n.add(T,T),new _(x,A,T)}add(m){q(m);const{X:p,Y:v,Z:S}=this,{X:C,Y:I,Z:x}=m;let A=n.ZERO,T=n.ZERO,M=n.ZERO;const j=i.a,W=n.mul(i.b,De);let R=n.mul(p,C),G=n.mul(v,I),z=n.mul(S,x),ut=n.add(p,v),Q=n.add(C,I);ut=n.mul(ut,Q),Q=n.add(R,G),ut=n.sub(ut,Q),Q=n.add(p,S);let nt=n.add(C,x);return Q=n.mul(Q,nt),nt=n.add(R,z),Q=n.sub(Q,nt),nt=n.add(v,S),A=n.add(I,x),nt=n.mul(nt,A),A=n.add(G,z),nt=n.sub(nt,A),M=n.mul(j,Q),A=n.mul(W,z),M=n.add(A,M),A=n.sub(G,M),M=n.add(G,M),T=n.mul(A,M),G=n.add(R,R),G=n.add(G,R),z=n.mul(j,z),Q=n.mul(W,Q),G=n.add(G,z),z=n.sub(R,z),z=n.mul(j,z),Q=n.add(Q,z),R=n.mul(G,Q),T=n.add(T,R),R=n.mul(nt,Q),A=n.mul(ut,A),A=n.sub(A,R),R=n.mul(ut,G),M=n.mul(nt,M),M=n.add(M,R),new _(A,T,M)}subtract(m){return this.add(m.negate())}is0(){return this.equals(_.ZERO)}multiply(m){const{endo:p}=t;if(!s.isValidNot0(m))throw new Error("invalid scalar: out of range");let v,S;const C=I=>at.cached(this,I,x=>fs(_,x));if(p){const{k1neg:I,k1:x,k2neg:A,k2:T}=V(m),{p:M,f:j}=C(x),{p:W,f:R}=C(T);S=j.add(R),v=$(p.beta,M,W,I,A)}else{const{p:I,f:x}=C(m);v=I,S=x}return fs(_,[v,S])[0]}multiplyUnsafe(m){const{endo:p}=t,v=this;if(!s.isValid(m))throw new Error("invalid scalar: out of range");if(m===Et||v.is0())return _.ZERO;if(m===jt)return v;if(at.hasCache(this))return this.multiply(m);if(p){const{k1neg:S,k1:C,k2neg:I,k2:x}=V(m),{p1:A,p2:T}=Pc(_,v,C,x);return $(p.beta,A,T,S,I)}else return at.unsafe(v,m)}toAffine(m){return F(this,m)}isTorsionFree(){const{isTorsionFree:m}=t;return o===jt?!0:m?m(_,this):at.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:m}=t;return o===jt?this:m?m(_,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(m=!0){return Ke(m,"isCompressed"),this.assertValidity(),d(_,this,m)}toHex(m=!0){return H(this.toBytes(m))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};k(_,"BASE",new _(i.Gx,i.Gy,n.ONE)),k(_,"ZERO",new _(n.ZERO,n.ONE,n.ZERO)),k(_,"Fp",n),k(_,"Fn",s);let L=_;const ft=s.BITS,at=new Sc(L,t.endo?Math.ceil(ft/2):ft);return L.BASE.precompute(8),L}function ks(r){return Uint8Array.of(r?2:3)}function _s(r,t){return{secretKey:t.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function Mc(r,t={}){const{Fn:e}=r,n=t.randomBytes||yt,s=Object.assign(_s(r.Fp,e),{seed:ls(e.ORDER)});function i(d){try{const y=e.fromBytes(d);return e.isValidNot0(y)}catch{return!1}}function o(d,y){const{publicKey:w,publicKeyUncompressed:b}=s;try{const P=d.length;return y===!0&&P!==w||y===!1&&P!==b?!1:!!r.fromBytes(d)}catch{return!1}}function c(d=n(s.seed)){return hs(D(d,s.seed,"seed"),e.ORDER)}function a(d,y=!0){return r.BASE.multiply(e.fromBytes(d)).toBytes(y)}function u(d){const{secretKey:y,publicKey:w,publicKeyUncompressed:b}=s;if(!kn(d)||"_lengths"in e&&e._lengths||y===w)return;const P=D(d,void 0,"key").length;return P===w||P===b}function l(d,y,w=!0){if(u(d)===!0)throw new Error("first arg must be private key");if(u(y)===!1)throw new Error("second arg must be public key");const b=e.fromBytes(d);return r.fromBytes(y).multiply(b).toBytes(w)}const h={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:c},f=ws(c,a);return Object.freeze({getPublicKey:a,getSharedSecret:l,keygen:f,Point:r,utils:h,lengths:s})}function Kc(r,t,e={}){Ur(t),Tn(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),e=Object.assign({},e);const n=e.randomBytes||yt,s=e.hmac||((m,p)=>se(t,m,p)),{Fp:i,Fn:o}=r,{ORDER:c,BITS:a}=o,{keygen:u,getPublicKey:l,getSharedSecret:h,utils:f,lengths:d}=Mc(r,e),y={prehash:!0,lowS:typeof e.lowS=="boolean"?e.lowS:!0,format:"compact",extraEntropy:!1},w=c*vs<i.ORDER;function b(m){const p=c>>jt;return m>p}function P(m,p){if(!o.isValidNot0(p))throw new Error(`invalid signature ${m}: out of range 1..Point.Fn.ORDER`);return p}function K(){if(w)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function B(m,p){Kn(p);const v=d.signature,S=p==="compact"?v:p==="recovered"?v+1:void 0;return D(m,S)}class q{constructor(p,v,S){k(this,"r");k(this,"s");k(this,"recovery");if(this.r=P("r",p),this.s=P("s",v),S!=null){if(K(),![0,1,2,3].includes(S))throw new Error("invalid recovery id");this.recovery=S}Object.freeze(this)}static fromBytes(p,v=y.format){B(p,v);let S;if(v==="der"){const{r:A,s:T}=It.toSig(D(p));return new q(A,T)}v==="recovered"&&(S=p[0],v="compact",p=p.subarray(1));const C=d.signature/2,I=p.subarray(0,C),x=p.subarray(C,C*2);return new q(o.fromBytes(I),o.fromBytes(x),S)}static fromHex(p,v){return this.fromBytes(U(p),v)}assertRecovery(){const{recovery:p}=this;if(p==null)throw new Error("invalid recovery id: must be present");return p}addRecoveryBit(p){return new q(this.r,this.s,p)}recoverPublicKey(p){const{r:v,s:S}=this,C=this.assertRecovery(),I=C===2||C===3?v+c:v;if(!i.isValid(I))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const x=i.toBytes(I),A=r.fromBytes(st(ks((C&1)===0),x)),T=o.inv(I),M=F(D(p,void 0,"msgHash")),j=o.create(-M*T),W=o.create(S*T),R=r.BASE.multiplyUnsafe(j).add(A.multiplyUnsafe(W));if(R.is0())throw new Error("invalid recovery: point at infinify");return R.assertValidity(),R}hasHighS(){return b(this.s)}toBytes(p=y.format){if(Kn(p),p==="der")return U(It.hexFromSig(this));const{r:v,s:S}=this,C=o.toBytes(v),I=o.toBytes(S);return p==="recovered"?(K(),st(Uint8Array.of(this.assertRecovery()),C,I)):st(C,I)}toHex(p){return H(this.toBytes(p))}}const V=e.bits2int||function(p){if(p.length>8192)throw new Error("input is too large");const v=re(p),S=p.length*8-a;return S>0?v>>BigInt(S):v},F=e.bits2int_modN||function(p){return o.create(V(p))},Y=xn(a);function $(m){return fc("num < 2^"+a,m,Et,Y),o.toBytes(m)}function L(m,p){return D(m,void 0,"message"),p?D(t(m),void 0,"prehashed message"):m}function ft(m,p,v){const{lowS:S,prehash:C,extraEntropy:I}=On(v,y);m=L(m,C);const x=F(m),A=o.fromBytes(p);if(!o.isValidNot0(A))throw new Error("invalid private key");const T=[$(A),$(x)];if(I!=null&&I!==!1){const R=I===!0?n(d.secretKey):I;T.push(D(R,void 0,"extraEntropy"))}const M=st(...T),j=x;function W(R){const G=V(R);if(!o.isValidNot0(G))return;const z=o.inv(G),ut=r.BASE.multiply(G).toAffine(),Q=o.create(ut.x);if(Q===Et)return;const nt=o.create(z*o.create(j+Q*A));if(nt===Et)return;let oo=(ut.x===Q?0:2)|Number(ut.y&jt),co=nt;return S&&b(nt)&&(co=o.neg(nt),oo^=1),new q(Q,co,w?void 0:oo)}return{seed:M,k2sig:W}}function at(m,p,v={}){const{seed:S,k2sig:C}=ft(m,p,v);return gc(t.outputLen,o.BYTES,s)(S,C).toBytes(v.format)}function _(m,p,v,S={}){const{lowS:C,prehash:I,format:x}=On(S,y);if(v=D(v,void 0,"publicKey"),p=L(p,I),!kn(m)){const A=m instanceof q?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+A)}B(m,x);try{const A=q.fromBytes(m,x),T=r.fromBytes(v);if(C&&A.hasHighS())return!1;const{r:M,s:j}=A,W=F(p),R=o.inv(j),G=o.create(W*R),z=o.create(M*R),ut=r.BASE.multiplyUnsafe(G).add(T.multiplyUnsafe(z));return ut.is0()?!1:o.create(ut.x)===M}catch{return!1}}function E(m,p,v={}){const{prehash:S}=On(v,y);return p=L(p,S),q.fromBytes(m,"recovered").recoverPublicKey(p).toBytes()}return Object.freeze({keygen:u,getPublicKey:l,getSharedSecret:h,utils:f,lengths:d,Point:r,sign:at,verify:_,recoverPublicKey:E,Signature:q,hash:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qe={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Oc={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Lc=BigInt(0),Ln=BigInt(2);function Rc(r){const t=qe.p,e=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),c=BigInt(44),a=BigInt(88),u=r*r*r%t,l=u*u*r%t,h=lt(l,e,t)*l%t,f=lt(h,e,t)*l%t,d=lt(f,Ln,t)*u%t,y=lt(d,s,t)*d%t,w=lt(y,i,t)*y%t,b=lt(w,c,t)*w%t,P=lt(b,a,t)*b%t,K=lt(P,c,t)*w%t,B=lt(K,e,t)*l%t,q=lt(B,o,t)*y%t,V=lt(q,n,t)*u%t,F=lt(V,Ln,t);if(!Fe.eql(Fe.sqr(F),r))throw new Error("Cannot find square root");return F}const Fe=Ne(qe.p,{sqrt:Rc}),Lt=Cc(qe,{Fp:Fe,endo:Oc}),O=Kc(Lt,Z),As={};function He(r,...t){let e=As[r];if(e===void 0){const n=Z(lc(r));e=st(n,n),As[r]=e}return Z(st(e,...t))}const Rn=r=>r.toBytes(!0).slice(1),Nn=r=>r%Ln===Lc;function Un(r){const{Fn:t,BASE:e}=Lt,n=t.fromBytes(r),s=e.multiply(n);return{scalar:Nn(s.y)?n:t.neg(n),bytes:Rn(s)}}function Ss(r){const t=Fe;if(!t.isValidNot0(r))throw new Error("invalid x: Fail if x  p");const e=t.create(r*r),n=t.create(e*r+BigInt(7));let s=t.sqrt(n);Nn(s)||(s=t.neg(s));const i=Lt.fromAffine({x:r,y:s});return i.assertValidity(),i}const ie=re;function Ps(...r){return Lt.Fn.create(ie(He("BIP0340/challenge",...r)))}function xs(r){return Un(r).bytes}function Nc(r,t,e=yt(32)){const{Fn:n}=Lt,s=D(r,void 0,"message"),{bytes:i,scalar:o}=Un(t),c=D(e,32,"auxRand"),a=n.toBytes(o^ie(He("BIP0340/aux",c))),u=He("BIP0340/nonce",a,i,s),{bytes:l,scalar:h}=Un(u),f=Ps(l,i,s),d=new Uint8Array(64);if(d.set(l,0),d.set(n.toBytes(n.create(h+f*o)),32),!Ts(d,s,i))throw new Error("sign: Invalid signature produced");return d}function Ts(r,t,e){const{Fp:n,Fn:s,BASE:i}=Lt,o=D(r,64,"signature"),c=D(t,void 0,"message"),a=D(e,32,"publicKey");try{const u=Ss(ie(a)),l=ie(o.subarray(0,32));if(!n.isValidNot0(l))return!1;const h=ie(o.subarray(32,64));if(!s.isValidNot0(h))return!1;const f=Ps(s.toBytes(l),Rn(u),c),d=i.multiplyUnsafe(h).add(u.multiplyUnsafe(s.neg(f))),{x:y,y:w}=d.toAffine();return!(d.is0()||!Nn(w)||y!==l)}catch{return!1}}const oe=(()=>{const e=(n=yt(48))=>hs(n,qe.n);return{keygen:ws(e,xs),getPublicKey:xs,sign:Nc,verify:Ts,Point:Lt,utils:{randomSecretKey:e,taggedHash:He,lift_x:Ss,pointToBytes:Rn},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),Uc=Fr("Secp256k1_HashToCurve_Cashu_");function Vt(r){const t=Z(N.concat(Uc,r)),e=new Uint32Array(1),n=2**16;for(let s=0;s<n;s++){const i=new Uint8Array(e.buffer),o=Z(N.concat(t,i));try{return Bt(H(N.concat(new Uint8Array([2]),o)))}catch{e[0]++}}throw new Error("No valid point found")}function Dn(r){const e=r.map(n=>n.toHex(!1)).join("");return Z(new TextEncoder().encode(e))}function Dc(r){return O.Point.fromHex(H(r))}function Bt(r){return O.Point.fromHex(r)}const Is=r=>{let t;return/^[a-fA-F0-9]+$/.test(r)?t=ye(r)%BigInt(2**31-1):t=N.toBigInt(dn(r))%BigInt(2**31-1),t};function $e(){return O.utils.randomSecretKey()}function qc(r,t,e,n){const s=O.Point.Fn.fromBytes(t);return{C_:r.multiply(s),amount:e,id:n}}function Fc(r){return Bs()}function Bs(){const r=H(yt(32)),t=new TextEncoder().encode(r);return ce(t)}function ce(r,t){const e=Vt(r);t||(t=O.Point.Fn.fromBytes($e()));const n=O.Point.BASE.multiply(t);return{B_:e.add(n),r:t,secret:r}}function Cs(r,t,e){return r.subtract(e.multiply(t))}function Ms(r,t,e,n){const s=n,i=Cs(r.C_,t,s);return{id:r.id,amount:r.amount,secret:e,C:i}}const Ks=r=>({amount:r.amount,C:r.C.toHex(!0),id:r.id,secret:new TextDecoder().decode(r.secret),witness:JSON.stringify(r.witness)}),Hc=r=>({amount:r.amount,C:Bt(r.C),id:r.id,secret:new TextEncoder().encode(r.secret),witness:r.witness?JSON.parse(r.witness):void 0}),qn=(r,t)=>{const e=Z(new TextEncoder().encode(r)),n=typeof t=="string"?U(t):t,s=oe.sign(e,n);return H(s)},ae=(r,t,e,n=!1)=>{try{const s=Z(new TextEncoder().encode(t)),i=e.length===66?e.slice(2):e;return oe.verify(U(r),s,U(i))}catch(s){if(n)throw s}return!1};function We(r,t,e){return Array.from(new Set(e)).filter(s=>r.some(i=>ae(i,t,s)))}const $c=(r,t,e,n=1)=>We(r,t,e).length>=n,Wc=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Os=Uint8Array.from(new Array(16).fill(0).map((r,t)=>t)),jc=Os.map(r=>(9*r+5)%16),Ls=(()=>{const e=[[Os],[jc]];for(let n=0;n<4;n++)for(let s of e)s.push(s[n].map(i=>Wc[i]));return e})(),Rs=Ls[0],Ns=Ls[1],Us=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(r=>Uint8Array.from(r)),Vc=Rs.map((r,t)=>r.map(e=>Us[t][e])),Gc=Ns.map((r,t)=>r.map(e=>Us[t][e])),zc=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),Qc=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function Ds(r,t,e,n){return r===0?t^e^n:r===1?t&e|~t&n:r===2?(t|~e)^n:r===3?t&n|e&~n:t^(e|~n)}const je=new Uint32Array(16);class Zc extends An{constructor(){super(64,20,8,!0);k(this,"h0",1732584193);k(this,"h1",-271733879);k(this,"h2",-1732584194);k(this,"h3",271733878);k(this,"h4",-1009589776)}get(){const{h0:e,h1:n,h2:s,h3:i,h4:o}=this;return[e,n,s,i,o]}set(e,n,s,i,o){this.h0=e|0,this.h1=n|0,this.h2=s|0,this.h3=i|0,this.h4=o|0}process(e,n){for(let y=0;y<16;y++,n+=4)je[y]=e.getUint32(n,!0);let s=this.h0|0,i=s,o=this.h1|0,c=o,a=this.h2|0,u=a,l=this.h3|0,h=l,f=this.h4|0,d=f;for(let y=0;y<5;y++){const w=4-y,b=zc[y],P=Qc[y],K=Rs[y],B=Ns[y],q=Vc[y],V=Gc[y];for(let F=0;F<16;F++){const Y=Ie(s+Ds(y,o,a,l)+je[K[F]]+b,q[F])+f|0;s=f,f=l,l=Ie(a,10)|0,a=o,o=Y}for(let F=0;F<16;F++){const Y=Ie(i+Ds(w,c,u,h)+je[B[F]]+P,V[F])+d|0;i=d,d=h,h=Ie(u,10)|0,u=c,c=Y}}this.set(this.h1+a+h|0,this.h2+l+d|0,this.h3+f+i|0,this.h4+s+c|0,this.h0+o+u|0)}roundClean(){At(je)}destroy(){this.destroyed=!0,At(this.buffer),this.set(0,0,0,0,0)}}const Yc=_n(()=>new Zc);/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */const ue=O.Point,{Fn:le}=ue,Fn=_o(Z),Xc=Uint8Array.from("Bitcoin seed".split(""),r=>r.charCodeAt(0)),Hn={private:76066276,public:76067358},$n=2147483648,Jc=r=>Yc(Z(r)),ta=r=>Ft(r).getUint32(0,!1),Ve=r=>{if(!Number.isSafeInteger(r)||r<0||r>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+r);const t=new Uint8Array(4);return Ft(t).setUint32(0,r,!1),t};class Ct{constructor(t){k(this,"versions");k(this,"depth",0);k(this,"index",0);k(this,"chainCode",null);k(this,"parentFingerprint",0);k(this,"_privateKey");k(this,"_publicKey");k(this,"pubHash");if(!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||Hn,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(this.depth>255)throw new Error("HDKey: depth exceeds the serializable value 255");if(t.publicKey&&t.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!O.utils.isValidSecretKey(t.privateKey))throw new Error("Invalid private key");this._privateKey=t.privateKey,this._publicKey=O.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this._publicKey=ue.fromBytes(t.publicKey).toBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=Jc(this._publicKey)}get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return ta(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this._privateKey||null}get publicKey(){return this._publicKey||null}get privateExtendedKey(){const t=this._privateKey;if(!t)throw new Error("No private key");return Fn.encode(this.serialize(this.versions.private,st(Uint8Array.of(0),t)))}get publicExtendedKey(){if(!this._publicKey)throw new Error("No public key");return Fn.encode(this.serialize(this.versions.public,this._publicKey))}static fromMasterSeed(t,e=Hn){if(D(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const n=se(Gr,Xc,t),s=n.slice(0,32),i=n.slice(32);return new Ct({versions:e,chainCode:i,privateKey:s})}static fromExtendedKey(t,e=Hn){const n=Fn.decode(t),s=Ft(n),i=s.getUint32(0,!1),o={versions:e,depth:n[4],parentFingerprint:s.getUint32(5,!1),index:s.getUint32(9,!1),chainCode:n.slice(13,45)},c=n.slice(45),a=c[0]===0;if(i!==e[a?"private":"public"])throw new Error("Version mismatch");return a?new Ct({...o,privateKey:c.slice(1)}):new Ct({...o,publicKey:c})}static fromJSON(t){return Ct.fromExtendedKey(t.xpriv)}derive(t){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const e=t.replace(/^[mM]'?\//,"").split("/");let n=this;for(const s of e){const i=/^(\d+)('?)$/.exec(s),o=i&&i[1];if(!i||i.length!==3||typeof o!="string")throw new Error("invalid child index: "+s);let c=+o;if(!Number.isSafeInteger(c)||c>=$n)throw new Error("Invalid index");i[2]==="'"&&(c+=$n),n=n.deriveChild(c)}return n}deriveChild(t){if(!this._publicKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let e=Ve(t);if(t>=$n){const a=this._privateKey;if(!a)throw new Error("Could not derive hardened child key");e=st(Uint8Array.of(0),a,e)}else e=st(this._publicKey,e);const n=se(Gr,this.chainCode,e),s=n.slice(0,32),i=n.slice(32);if(!O.utils.isValidSecretKey(s))throw new Error("Tweak bigger than curve order");const o={versions:this.versions,chainCode:i,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t},c=le.fromBytes(s);try{if(this._privateKey){const a=le.create(le.fromBytes(this._privateKey)+c);if(!le.isValidNot0(a))throw new Error("The tweak was out of range or the resulted private key is invalid");o.privateKey=le.toBytes(a)}else{const a=ue.fromBytes(this._publicKey).add(ue.BASE.multiply(c));if(a.equals(ue.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");o.publicKey=a.toBytes(!0)}return new Ct(o)}catch{return this.deriveChild(t+1)}}sign(t){if(!this._privateKey)throw new Error("No privateKey set!");return D(t,32),O.sign(t,this._privateKey,{prehash:!1})}verify(t,e){if(D(t,32),D(e,64),!this._publicKey)throw new Error("No publicKey set!");return O.verify(e,t,this._publicKey,{prehash:!1})}wipePrivateData(){return this._privateKey&&(this._privateKey.fill(0),this._privateKey=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,e){if(!this.chainCode)throw new Error("No chainCode set");return D(e,33),st(Ve(t),new Uint8Array([this.depth]),Ve(this.parentFingerprint),Ve(this.index),this.chainCode,e)}}const qs="m/0'/0'/0'";function Fs(r){const t={};return Object.keys(r).forEach(e=>{t[e]=H(r[e])}),t}function ea(r){const t={};return Object.keys(r).forEach(e=>{t[e]=U(r[e])}),t}function Hs(r){return O.getPublicKey(r,!0)}function na(r,t,e){const{expiry:n,input_fee_ppk:s,unit:i="sat",versionByte:o=1}=e||{};let c=0n;const a={},u={};let l;for(t&&(l=Ct.fromMasterSeed(t));c<r;){const f=(2n**c).toString();if(l){const d=l.derive(`${qs}/${c}`).privateKey;if(d)u[f]=d;else throw new Error(`Could not derive Private key from: ${qs}/${c}`)}else u[f]=$e();a[f]=Hs(u[f]),c++}const h=nn(Fs(a),{expiry:n,input_fee_ppk:s,unit:i,versionByte:o});return{pubKeys:a,privKeys:u,keysetId:h}}function ra(r,t){const e=Vt(r.secret),n=O.Point.Fn.fromBytes(t);return e.multiply(n).equals(r.C)}function Wn(r,t,e){const n=[r,{nonce:H(yt(32)),data:t,tags:e}];return JSON.stringify(n)}function he(r){let t;try{typeof r=="string"?t=JSON.parse(r):t=r}catch{throw new Error("Can't parse secret")}if(!Array.isArray(t)||t.length!==2||typeof t[0]!="string"||typeof t[1]!="object"||t[0].trim().length===0||t[1]===null)throw new Error("Invalid NUT-10 secret");const[e,n]=t;if(typeof n.nonce!="string"||typeof n.data!="string")throw new Error("Invalid NUT-10 secret nonce / data");if(n.tags){if(!Array.isArray(n.tags))throw new Error("Invalid NUT-10 secret tags");if(n.tags.some(i=>!Array.isArray(i)||i.length===0||i.some(o=>typeof o!="string"||!o.length)))throw new Error("Invalid NUT-10 tag(s)")}return[e,{nonce:n.nonce,data:n.data,tags:n.tags}]}function jn(r,t){const e=Array.isArray(r)?r:[r],n=he(t),s=n[0];if(!e.includes(s))throw new Error(`Invalid secret kind: ${s} Allowed: ${e.join(", ")}`);return n}function Vn(r){return he(r)[0]}function Gn(r){return he(r)[1]}function zn(r){const{data:t}=Gn(r);return t}function Qn(r){const{tags:t}=Gn(r);return t??[]}function sa(r,t){return Qn(r).some(e=>e[0]===t)}function Ge(r,t){const e=Qn(r).find(n=>n[0]===t);if(!(!e||e.length<=1))return e.slice(1)}function Zn(r,t){const e=Ge(r,t);return e&&e.length>0?e[0]:void 0}function ze(r,t){const e=Zn(r,t);if(e===void 0)return;const n=Number.parseInt(e,10);return Number.isFinite(n)?n:void 0}const Yn=Fr("Cashu_P2BK_v1");function $s(r,t,e){if(!r.length)return{blinded:[],Ehex:""};e=e??O.utils.randomSecretKey();const n=O.Point.Fn.fromBytes(e),s=O.getPublicKey(e,!0),i=U(t);return{blinded:r.map((c,a)=>{const u=Bt(c),l=Vs(u,n,i,a),h=u.add(O.Point.BASE.multiply(l));if(h.equals(O.Point.ZERO))throw new Error("Blinded key at infinity");return h.toHex(!0)}),Ehex:H(s)}}function Ws(r,t,e,n){const s=Array.isArray(t)?t:[t],i=Array.isArray(e)?e:[e],o=new Set,c=O.Point.fromHex(r),a=U(n);for(const u of s){const l=O.Point.Fn.fromBytes(U(u)),h=O.getPublicKey(U(u),!0);i.forEach((f,d)=>{const y=Vs(c,l,a,d),w=U(f),b=js(u,y,w,h);b&&o.add(b)})}return Array.from(o)}function js(r,t,e,n){const s=O.Point.CURVE().n,i=typeof r=="string"?ye(r):r,o=typeof t=="string"?ye(t):t;if(i<=0n||i>=s)throw new Error("Invalid private key");if(o<=0n||o>=s)throw new Error("Invalid scalar r");if(n=n??O.Point.BASE.multiply(i).toBytes(!0),n.length!==33)throw new Error("naturalPub must be 33 bytes");const c=(i+o)%s,a=(s-i+o)%s;if(!e){if(c===0n)throw new Error("Derived secret key is zero");return Je(c)}if(e.length!==33)throw new Error("blindPubkey must be 33 bytes");const u=O.Point.fromHex(H(e)),l=O.Point.BASE.multiply(o),h=u.subtract(l);if(h.equals(O.Point.ZERO))return null;const f=h.toBytes(!0).slice(1),d=n.slice(1);if(!N.equals(f,d))return null;const y=h.toBytes(!0)[0]&1,w=n[0]&1,b=y===w?c:a;if(b===0n)throw new Error("Derived secret key is zero");return Je(b)}function Vs(r,t,e,n){const s=r.multiply(t).toBytes(!0).slice(1),i=new Uint8Array([n&255]);let o=N.toBigInt(Z(N.concat(Yn,s,e,i)));if((o===0n||o>=O.Point.CURVE().n)&&(o=N.toBigInt(Z(N.concat(Yn,s,e,i,new Uint8Array([255])))),o===0n||o>=O.Point.CURVE().n))throw new Error("P2BK: tweak derivation failed");return o}function ia(r,t){return Wn("P2PK",r,t)}function ot(r){return r instanceof Uint8Array&&(r=new TextDecoder().decode(r)),jn(["P2PK","HTLC"],r)}function Xn(r){try{const t=ot(r),e=fe(t),n=Qe(t),s=Gt(t);if(e==="ACTIVE"||e==="PERMANENT")return n;if(e==="EXPIRED"&&s.length){const i=[...n,...s];return Array.from(new Set(i))}}catch{}return[]}function Qe(r){const t=ot(r);let e="";Vn(t)==="P2PK"&&(e=zn(t));const n=Ge(t,"pubkeys")??[],s=[e,...n].filter(Boolean);return Array.from(new Set(s))}function Gt(r){const t=ot(r);return Ge(t,"refund")??[]}function Gs(r){const t=ot(r),e=ze(t,"locktime");return e===void 0||!Number.isFinite(e)||e<=0?1/0:e}function fe(r,t=Math.floor(Date.now()/1e3)){const e=ot(r),n=Gs(e);return Number.isFinite(n)?t<n?"ACTIVE":"EXPIRED":"PERMANENT"}function zs(r){const t=ot(r),e=fe(t);return!Gt(t).length&&e==="EXPIRED"?0:ze(t,"n_sigs")??1}function Qs(r){const t=ot(r),e=fe(t);return Gt(t).length&&e==="EXPIRED"?ze(t,"n_sigs_refund")??1:0}function Ze(r){const t=ot(r);return Zn(t,"sigflag")==="SIG_ALL"?"SIG_ALL":"SIG_INPUTS"}function Ye(r){return Zs(r)?.signatures??[]}function Zs(r){if(!r)return;let t;try{t=typeof r=="string"?JSON.parse(r):r}catch(n){console.error("Failed to parse witness string:",n);return}const e={signatures:t.signatures??[]};return typeof t.preimage=="string"&&t.preimage.length>0&&(e.preimage=t.preimage),e}function Jn(r,t,e=X,n){const s=o=>typeof o=="string"?o:H(o),i=Array.isArray(t)?t.map(s):s(t);return r.map((o,c)=>{const a=Js(i,o);let u=o;for(const l of a)try{u=Ys(u,l,n)}catch(h){const f=h instanceof Error?h.message:"Unknown error";e.warn(`Proof #${c+1}: ${f}`)}return u})}function Ys(r,t,e){const n=ot(r.secret);e=e??r.secret;const s=typeof t=="string"?U(t):t,i=H(oe.getPublicKey(s)),o=Xn(n);if(!o.length||!o.some(f=>f.includes(i)))throw new Error(`Signature not required from [02|03]${i}`);if(Ye(r.witness).some(f=>ae(f,e,i)))throw new Error(`Proof already signed by [02|03]${i}`);const u=qn(e,t),l=Zs(r.witness),h={...l&&l.preimage!==void 0?{preimage:l.preimage}:{},signatures:[...l?.signatures??[],u]};return{...r,witness:h}}function oa(r,t,e){if(!t.witness)return!1;if(de([t])&&!e)throw new Error("Cannot verify a SIG_ALL proof without the message to sign");return e=e??t.secret,Ye(t.witness).some(s=>ae(s,e,r))}function tr(r,t=X,e){if(de([r])&&!e)throw t.error("Cannot verify a SIG_ALL proof without the message to sign"),new Error("Cannot verify a SIG_ALL proof without the message to sign");e=e??r.secret;const n=ot(r.secret),s=Ye(r.witness),i=fe(n),o=Qe(n),c=zs(n),a=We(s,e,o),u={success:!0,path:"MAIN",lockState:i,requiredSigners:c,eligibleSigners:o.length,receivedSigners:a};let l=u;if(o.length&&c>0&&a.length>=c)return t.debug("Spending condition satisfied via main pubkeys",{result:l}),l;if(i!=="EXPIRED")return l={...u,success:!1,path:"FAILED"},t.debug("P2PK lock enabled, but threshold not met by main pubkeys",{result:l}),l;t.debug("P2PK lock expired. Checking refund path.",{lockState:i});const h=Gt(n);if(h.length){const f=Qs(n),d=We(s,e,h),y={...u,path:"REFUND",requiredSigners:f,eligibleSigners:h.length,receivedSigners:d};return f>0&&d.length>=f?(l=y,t.debug("Spending condition satisfied via refund pubkeys",{result:l}),l):(l={...y,success:!1,path:"FAILED"},t.debug("Spending threshold not met by refund pubkeys",{result:l}),l)}return l={...u,path:"UNLOCKED"},t.debug("No refund pubkeys, anyone can spend.",{result:l}),l}function Xs(r,t=X,e){return tr(r,t,e).success}function Js(r,t){const e=Array.isArray(r)?r:[r],n=t?.p2pk_e;if(!n)return Array.from(new Set(e));const s=ot(t.secret),i=[...Qe(s),...Gt(s)],o=t.id;return Ws(n,e,i,o)}function ti(r){if(r.length===0)throw new Error("No proofs");const t=ot(r[0].secret);if(Ze(t)!=="SIG_ALL")throw new Error("First proof is not SIG_ALL");const e=t[1].data,n=JSON.stringify(t[1].tags??[]);for(let s=1;s<r.length;s++){const i=ot(r[s].secret);if(i[0]!==t[0])throw new Error(`Proof #${s+1} is not ${t[0]}`);if(Ze(i)!=="SIG_ALL")throw new Error(`Proof #${s+1} is not SIG_ALL`);if(i[1].data!==e)throw new Error("SIG_ALL inputs must share identical Secret.data");if(JSON.stringify(i[1].tags??[])!==n)throw new Error("SIG_ALL inputs must share identical Secret.tags")}}function ei(r,t,e){const n=[];for(const s of r)n.push(s.secret,s.C);for(const s of t)n.push(String(s.blindedMessage.amount),s.blindedMessage.B_);return e&&n.push(e),n.join("")}function de(r){return r.some(t=>{try{return Ze(t.secret)==="SIG_ALL"}catch{return!1}})}function ni(r,t,e){const n=[];for(const s of r)n.push(s.secret,s.C);for(const s of t)n.push(String(s.blindedMessage.amount),s.blindedMessage.id,s.blindedMessage.B_);return e&&n.push(e),n.join("")}function ri(r,t,e){const n=[];for(const s of r)n.push(s.secret);for(const s of t)n.push(s.blindedMessage.B_);return e&&n.push(e),n.join("")}const ca=(r,t)=>qn(r,t),aa=(r,t,e)=>ae(r,t,e);function ua(r){return Xn(r)}function la(r){return Xs(r)}function ha(r,t){if(r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}const si=(r,t,e,n)=>{const s=O.Point.Fn.fromBytes(r.s),i=O.Point.Fn.fromBytes(r.e),o=O.Point.BASE.multiply(s),c=n.multiply(i),a=t.multiply(s),u=e.multiply(i),l=o.subtract(c),h=a.subtract(u),f=Dn([l,h,n,e]);return ha(f,r.e)},ii=(r,t,e,n)=>{if(t.r===void 0)throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");const s=Vt(r),i=e.add(n.multiply(t.r)),o=O.Point.BASE.multiply(t.r),c=s.add(o);return si(t,c,i,n)},fa=(r,t)=>{const e=O.Point.Fn.fromBytes($e()),n=O.Point.BASE.multiply(e),s=r.multiply(e),i=O.Point.Fn.fromBytes(t),o=r.multiply(i),c=O.Point.BASE.multiply(i),a=Dn([n,s,c,o]),u=O.Point.Fn.fromBytes(a),l=O.Point.Fn.add(e,O.Point.Fn.mul(u,i));return{s:Le(l,32),e:a}},da="m/129372'/0'",oi=BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"),ci=(r,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&ve(t)||n&&t.startsWith("00"))return Xe(r,t,e,0);if(n&&t.startsWith("01"))return ui(r,t,e,0);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},ai=(r,t,e)=>{const n=/^[a-fA-F0-9]+$/.test(t);if(!n&&ve(t)||n&&t.startsWith("00"))return Xe(r,t,e,1);if(n&&t.startsWith("01"))return ui(r,t,e,1);throw new Error(`Unrecognized keyset ID version ${t.slice(0,2)}`)},ui=(r,t,e,n)=>{let s=N.concat(N.fromString("Cashu_KDF_HMAC_SHA256"),N.fromHex(t),N.writeBigUint64BE(BigInt(e)));switch(n){case 0:s=N.concat(s,N.fromHex("00"));break;case 1:s=N.concat(s,N.fromHex("01"))}const i=se(Z,r,s);if(n===1){const o=N.toBigInt(i);if(o>=oi)return N.fromBigInt(o-oi);if(o===0n)throw new Error("Derived invalid blinding scalar r == 0");return i}return i},Xe=(r,t,e,n)=>{const s=Ct.fromMasterSeed(r),i=Is(t),o=`${da}/${i}'/${e}'/${n}`,c=s.derive(o);if(c.privateKey===null)throw new Error("Could not derive private key");return c.privateKey};function ga(r,t){return Wn("HTLC",r,t)}function pa(r){return jn("HTLC",r)}function li(r){const t=r!==void 0;if(t&&!/^[0-9a-f]{64}$/i.test(r))throw new Error("Preimage must be a 64 character hexadecimal string (32 bytes).");const e=t?U(r):yt(32);return{hash:H(Z(e)),preimage:H(e)}}function hi(r,t){const{hash:e}=li(r);return t===e}function fi(r,t=X,e){let n;e=e??r.secret;const s=he(r.secret),i=tr(r,t,e);if(i.path!="MAIN"||Vn(s)!=="HTLC")return i;const o=di(r.witness);if(!o)return n={...i,success:!1,path:"FAILED"},t.debug("Hashlock spend failed, no preimage found",{result:n}),n;const c=zn(s);return hi(o,c)?(n=i,t.debug("Spending condition satisfied via hashlock (receiver) pathway",{result:n}),n):(n={...i,success:!1,path:"FAILED"},t.debug("Hashlock spend failed, wrong preimage for hash",{result:n}),n)}function ya(r,t=X,e){return fi(r,t,e).success}function di(r){if(!r)return;let t;try{t=typeof r=="string"?JSON.parse(r):r}catch(n){console.error("Failed to parse HTLC witness string:",n);return}const e=t.preimage;return typeof e=="string"&&e.length>0?e:void 0}function gi(r,t){let e=r;for(const s of t)e+=s.B_;const n=new TextEncoder().encode(e);return Z(n)}function pi(r,t,e){const n=gi(t,e),s=U(r),i=oe.sign(n,s);return H(i)}function ma(r,t,e,n){const s=U(n);let i=U(r);if(i.length!==33)return!1;i=i.slice(1);const o=gi(t,e);return oe.verify(s,o,i)}var ge=(r=>(r.POST="post",r.NOSTR="nostr",r))(ge||{});const yi=1,mi=2,er=3,wi=4,bi=5,Ei=6,vi=7,ki=8,_i=1,Ai=2,Si=3,nr=0,Pi=1,xi=1,Ti=2,Ii=3,Bi=0,Ci=1;function wa(r){const t=rr(r),e={};for(const n of t)switch(n.tag){case yi:e.id=Rt(n.value);break;case mi:e.amount=Ea(n.value);break;case er:n.value.length===1&&n.value[0]===0?e.unit="sat":e.unit=Rt(n.value);break;case wi:e.singleUse=sr(n.value)===1;break;case bi:e.mints||(e.mints=[]),e.mints.push(Rt(n.value));break;case Ei:e.description=Rt(n.value);break;case vi:e.transports||(e.transports=[]),e.transports.push(_a(n.value));break;case ki:e.nut10||(e.nut10=[]),e.nut10.push(Aa(n.value));break}return e}function rr(r){const t=[];let e=0;for(;e<r.length;){const n=ba(r.subarray(e));t.push(n),e+=3+n.length}return t}function ba(r){if(r.length<3)throw new Error("TLV data too short: need at least 3 bytes for tag and length");const t=new DataView(r.buffer,r.byteOffset,r.byteLength),e=t.getUint8(0),n=t.getUint16(1,!1);if(r.length<3+n)throw new Error(`TLV data too short: expected ${3+n} bytes, got ${r.length}`);const s=r.subarray(3,3+n);return{tag:e,length:n,value:s}}function Rt(r){return new TextDecoder().decode(r)}function Ea(r){if(r.length!==8)throw new Error(`Invalid u64: expected 8 bytes, got ${r.length}`);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,!1)}function sr(r){if(r.length!==1)throw new Error(`Invalid u8: expected 1 byte, got ${r.length}`);return r[0]}function va(r){switch(r){case nr:return"nostr";case Pi:return"post";default:throw new Error(`Unsupported transport kind: ${r}`)}}function ka(r){switch(r){case Bi:return"P2PK";case Ci:return"HTLC";default:throw new Error(`Unsupported NUT-10 kind: ${r}`)}}function _a(r){const t=rr(r);let e,n,s;for(const c of t)switch(c.tag){case _i:e=sr(c.value);break;case Ai:n=c.value;break;case Si:s||(s=[]),s.push(Mi(c.value));break}if(e===void 0)throw new Error("Transport missing required kind field");if(n===void 0)throw new Error("Transport missing required target field");let i;if(e===nr){const c=s?.filter(a=>a[0]==="r").flatMap(a=>a.slice(1))??[];i=Ma(n,c),s=s?.filter(a=>a[0]!=="r")}else i=Rt(n);const o=s&&s.length>0?s:void 0;return{type:va(e),target:i,tags:o}}function Aa(r){const t=rr(r);let e,n,s;for(const o of t)switch(o.tag){case xi:e=sr(o.value);break;case Ti:n=Rt(o.value);break;case Ii:s||(s=[]),s.push(Mi(o.value));break}if(e===void 0)throw new Error("NUT-10 spending condition missing required kind field");if(n===void 0)throw new Error("NUT-10 spending condition missing required data field");const i=s&&s.length>0?s:void 0;return{kind:ka(e),data:n,tags:i}}function Mi(r){const t=[];let e=0;for(;e<r.length;){const n=r[e];if(e+=1,r.length-e<n)throw new Error(`Tag tuple data too short: expected ${n} bytes, got ${r.length-e}`);const s=Rt(r.subarray(e,e+n));t.push(s),e+=n}return t}function Sa(r){const t=[];if(r.id&&t.push(et(yi,zt(r.id))),r.amount!==void 0&&t.push(et(mi,Pa(r.amount))),r.unit&&(r.unit==="sat"?t.push(et(er,new Uint8Array([0]))):t.push(et(er,zt(r.unit)))),r.singleUse!==void 0&&t.push(et(wi,ir(r.singleUse?1:0))),r.mints&&r.mints.length>0)for(const i of r.mints)t.push(et(bi,zt(i)));if(r.description&&t.push(et(Ei,zt(r.description))),r.transports&&r.transports.length>0)for(const i of r.transports)t.push(et(vi,Ia(i)));if(r.nut10&&r.nut10.length>0)for(const i of r.nut10)t.push(et(ki,Ba(i)));const e=t.reduce((i,o)=>i+o.length,0),n=new Uint8Array(e);let s=0;for(const i of t)n.set(i,s),s+=i.length;return n}function et(r,t){const e=t.length;if(e>65535)throw new Error(`TLV value too long: ${e} bytes (max 65535)`);const n=new Uint8Array(3+e);return n[0]=r,n[1]=e>>8&255,n[2]=e&255,n.set(t,3),n}function zt(r){return new TextEncoder().encode(r)}function Pa(r){const t=new ArrayBuffer(8);return new DataView(t).setBigUint64(0,r,!1),new Uint8Array(t)}function ir(r){return new Uint8Array([r])}function xa(r){switch(r){case ge.NOSTR:return nr;case ge.POST:return Pi;default:throw new Error(`Unsupported transport type: ${r}`)}}function Ta(r){switch(r){case"P2PK":return Bi;case"HTLC":return Ci;default:throw new Error(`Unsupported NUT-10 type: ${r}`)}}function Ia(r){const t=[],e=xa(r.type);t.push(et(_i,ir(e)));let n,s=[];if(r.type===ge.NOSTR){const{pubkey:u,relays:l}=Ca(r.target);n=u,s=l.map(h=>["r",h])}else n=zt(r.target);t.push(et(Ai,n));const i=[...s,...r.tags||[]];if(i.length>0)for(const u of i)t.push(et(Si,Ki(u)));const o=t.reduce((u,l)=>u+l.length,0),c=new Uint8Array(o);let a=0;for(const u of t)c.set(u,a),a+=u.length;return c}function Ba(r){const t=[],e=Ta(r.kind);if(t.push(et(xi,ir(e))),t.push(et(Ti,zt(r.data))),r.tags&&r.tags.length>0)for(const o of r.tags)t.push(et(Ii,Ki(o)));const n=t.reduce((o,c)=>o+c.length,0),s=new Uint8Array(n);let i=0;for(const o of t)s.set(o,i),i+=o.length;return s}function Ki(r){const t=new TextEncoder,e=[];for(const o of r){const c=t.encode(o);if(c.length>255)throw new Error(`Tag tuple string too long: ${o} (max 255 bytes)`);const a=new Uint8Array(1+c.length);a[0]=c.length,a.set(c,1),e.push(a)}const n=e.reduce((o,c)=>o+c.length,0),s=new Uint8Array(n);let i=0;for(const o of e)s.set(o,i),i+=o.length;return s}function Ca(r){const t=Se.decode(r,1024);if(t.prefix!=="nprofile")throw new Error(`Invalid nprofile: expected prefix 'nprofile', got '${t.prefix}'`);const e=Se.fromWords(t.words),n=new Uint8Array(e);let s;const i=[];let o=0;for(;o<n.length;){if(o+2>n.length)throw new Error("Nprofile TLV data too short");const c=n[o],a=n[o+1];if(o+=2,o+a>n.length)throw new Error(`Nprofile TLV value too short: expected ${a} bytes`);const u=n.subarray(o,o+a);if(o+=a,c===0){if(u.length!==32)throw new Error(`Invalid pubkey length: expected 32 bytes, got ${u.length}`);s=u}else c===1&&i.push(new TextDecoder().decode(u))}if(!s)throw new Error("Nprofile missing required pubkey");return{pubkey:s,relays:i}}function Ma(r,t){const e=Ka(r,t),n=Se.toWords(e);return Se.encode("nprofile",n,1024)}function Ka(r,t){if(r.length!==32)throw new Error(`Invalid pubkey: expected 32 bytes, got ${r.length}`);const e=new TextEncoder,n=t.map(c=>e.encode(c));for(let c=0;c<n.length;c++)if(n[c].length>255)throw new Error(`Relay URL too long: ${t[c]} (max 255 bytes)`);const s=34+n.reduce((c,a)=>c+2+a.length,0),i=new Uint8Array(s);let o=0;i[o++]=0,i[o++]=32,i.set(r,o),o+=32;for(const c of n)i[o++]=1,i[o++]=c.length,i.set(c,o),o+=c.length;return i}class pe{constructor(t,e,n,s,i,o,c=!1,a,u=!1){this.transport=t,this.id=e,this.amount=n,this.unit=s,this.mints=i,this.description=o,this.singleUse=c,this.nut10=a,this.nut26=u}toRawRequest(){const t={};return this.transport&&(t.t=this.transport.map(e=>({t:e.type,a:e.target,g:e.tags}))),this.id&&(t.i=this.id),this.amount&&(t.a=this.amount),this.unit&&(t.u=this.unit),this.mints&&(t.m=this.mints),this.description&&(t.d=this.description),this.singleUse&&(t.s=this.singleUse),this.nut10&&(t.nut10={k:this.nut10.kind,d:this.nut10.data,t:this.nut10.tags}),this.nut26&&(t.nut26=this.nut26),t}toEncodedRequest(){const t=this.toRawRequest(),e=bn(t);return"creqA"+N.toBase64(e)}toEncodedCreqA(){return this.toEncodedRequest()}toEncodedCreqB(){const t={id:this.id,amount:this.amount!==void 0?BigInt(this.amount):void 0,unit:this.unit,singleUse:this.singleUse,mints:this.mints,description:this.description,transports:this.transport,nut10:this.nut10?[{kind:this.nut10.kind,data:this.nut10.data,tags:this.nut10.tags}]:void 0},e=Sa(t);return So("creqb",e).toUpperCase()}getTransport(t){return this.transport?.find(e=>e.type===t)}static fromRawRequest(t){const e=t.t?t.t.map(s=>({type:s.t,target:s.a,tags:s.g})):void 0,n=t.nut10?{kind:t.nut10.k,data:t.nut10.d,tags:t.nut10.t}:void 0;return new pe(e,t.i,t.a,t.u,t.m,t.d,t.s,n,t.nut26)}static fromEncodedRequest(t){const e=t.toLowerCase();if(e.startsWith("creqb")){const c=xo(e),a=wa(c);return new pe(a.transports,a.id,a.amount!==void 0?Number(a.amount):void 0,a.unit,a.mints,a.description,a.singleUse??!1,void 0,!1)}if(!t.startsWith("creq"))throw new Error("unsupported pr: invalid prefix");if(t[4]!=="A")throw new Error("unsupported pr version");const s=t.slice(5),i=dn(s),o=vn(i);return this.fromRawRequest(o)}}function vt(r,t,e,n){if(e){const i=Wi(e);if(r===0&&i===0)return e;const o=e.filter(a=>a>0),c=Wi(o);if(c>r)throw new Error(`Split is greater than total amount: ${c} > ${r}`);if(o.some(a=>!cr(a,t)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");if(c===r)return o;e=o,r-=c}else e=[];const s=or(t,"desc");if(!s||s.length===0)throw new Error("Cannot split amount, keyset is inactive or contains no keys");for(const i of s){if(i<=0)continue;const o=Math.floor(r/i);if(e.push(...Array(o).fill(i)),r-=i*o,r===0)break}if(r!==0)throw new Error(`Unable to split remaining amount: ${r}`);return n?e.sort((i,o)=>n==="desc"?o-i:i-o):e}function Oi(r,t,e,n){const s=[],i=r.map(a=>a.amount);or(e,"asc").forEach(a=>{const u=i.filter(h=>h===a).length,l=Math.max(n-u,0);for(let h=0;h<l&&!(s.reduce((f,d)=>f+d,0)+a>t);++h)s.push(a)});const c=t-s.reduce((a,u)=>a+u,0);return c&&vt(c,e).forEach(u=>{s.push(u)}),s.sort((a,u)=>a-u)}function or(r,t="desc"){return t=="desc"?Object.keys(r).map(e=>parseInt(e)).sort((e,n)=>n-e):Object.keys(r).map(e=>parseInt(e)).sort((e,n)=>e-n)}function cr(r,t){return r in t}function Oa(r){return N.toBigInt(r)}function ye(r){return BigInt(`0x${r}`)}function Je(r){return r.toString(16).padStart(64,"0")}function Nt(r){return/^[a-f0-9]*$/i.test(r)}function tn(r){return Array.isArray(r)?r.some(t=>!Nt(t.id)):!Nt(r.id)}function La(r,t){return typeof t=="bigint"?t.toString():t}function Li(r,t){tn(r.proofs)||(r.proofs=Ri(r.proofs)),t&&(r.proofs=lr(r.proofs));const e={token:[{mint:r.mint,proofs:r.proofs}]};return r.unit&&(e.unit=r.unit),r.memo&&(e.memo=r.memo),"cashu"+"A"+Sr(e)}function Ri(r){return r.map(t=>{const e={...t};return e.id=e.id.slice(0,16),e})}function Ra(r,t){if(tn(r.proofs)||t?.version===3){if(t?.version===4)throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");return Li(r,t?.removeDleq)}return Ni(r,t?.removeDleq)}function Ni(r,t){if(t&&(r.proofs=lr(r.proofs)),r.proofs.forEach(a=>{if(a.dleq&&a.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),tn(r.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");r.proofs=Ri(r.proofs);const n=Ui(r),s=bn(n),i="cashu",o="B",c=fn(s);return i+o+c}function Ui(r){const t={},e=r.mint;for(let s=0;s<r.proofs.length;s++){const i=r.proofs[s];t[i.id]?t[i.id].push(i):t[i.id]=[i]}const n={m:e,u:r.unit||"sat",t:Object.keys(t).map(s=>({i:U(s),p:t[s].map(i=>({a:i.amount,s:i.secret,c:U(i.C),...i.dleq&&{d:{e:U(i.dleq.e),s:U(i.dleq.s),r:U(i.dleq.r??"00")}},...i.p2pk_e&&{pe:U(i.p2pk_e)},...i.witness&&{w:JSON.stringify(i.witness)}}))}))};return r.memo&&(n.d=r.memo),n}function en(r,t=!1){if(typeof r!="number"||!Number.isFinite(r)||!Number.isInteger(r))throw new Error(`Invalid amount: ${String(r)}`);if(!Number.isSafeInteger(r))throw new Error(`Amount must be a safe integer: ${r}`);if(t?r<0:r<=0)throw new Error(`Amount must be ${t?"non-negative":"positive"}: ${r}`)}function Di(r){const t=[];r.t.forEach(n=>n.p.forEach(s=>{en(s.a,!0),t.push({secret:s.s,C:H(s.c),amount:s.a,id:H(n.i),...s.d&&{dleq:{r:H(s.d.r),s:H(s.d.s),e:H(s.d.e)}},...s.pe&&{p2pk_e:H(s.pe)},...s.w&&{witness:s.w}})}));const e={mint:r.m,proofs:t,unit:r.u||"sat"};return r.d&&(e.memo=r.d),e}function qi(r,t){const e=(t??[]).map(i=>typeof i=="string"?i:i.id),n=ji(r),s=ar(n);return s.proofs=Ha(s.proofs,e),s}function Na(r){r=ji(r);const t=ar(r);return{unit:t.unit||"sat",mint:t.mint,amount:Ut(t.proofs),...t.memo&&{memo:t.memo},incompleteProofs:t.proofs.map(e=>({secret:e.secret,C:e.C,amount:e.amount,...e.dleq&&{dleq:e.dleq},...e.witness&&{witness:e.witness}}))}}function ar(r){const t=r.slice(0,1),e=r.slice(1);if(t==="A"){const n=yo(e);if(n.token.length>1)throw new Error("Multi entry token are not supported");const s=n.token[0];for(const o of s.proofs)en(o.amount,!0);const i={mint:s.mint,proofs:s.proofs,unit:n.unit||"sat"};return n.memo&&(i.memo=n.memo),i}else if(t==="B"){const n=dn(e),s=vn(n);return Di(s)}throw new Error("Token version is not supported")}function nn(r,t,e,n,s,i){let o="sat";if(t&&typeof t=="object"?(o=t.unit??"sat",e=t.expiry,n=t.versionByte??1,i=t.input_fee_ppk,s=t.isDeprecatedBase64??!1):(o=t??"sat",n=n??0,s=s??!1),s){const c=Object.entries(r).sort(([l],[h])=>Number(l)-Number(h)).map(([,l])=>l).reduce((l,h)=>l+h,""),a=Z(N.fromString(c));return N.toBase64(a).slice(0,12)}switch(n){case 0:{const c=Object.entries(r).sort(([l],[h])=>Number(l)-Number(h)).map(([,l])=>U(l)).reduce((l,h)=>Fi(l,h),new Uint8Array),a=Z(c);return"00"+N.toHex(a).slice(0,14)}case 1:{if(!o)throw new Error("Cannot compute keyset ID version 01: unit is required.");let a=Object.entries(r).sort(([h],[f])=>Number(h)-Number(f)).map(([h,f])=>`${h}:${f}`).join(",");a+=`|unit:${o}`,i&&(a+=`|input_fee_ppk:${i}`),e&&(a+=`|final_expiry:${e}`);const u=Z(N.fromString(a));return"01"+N.toHex(u)}default:throw new Error(`Unrecognized keyset ID version: ${n}`)}}function Fi(r,t){const e=new Uint8Array(r.length+t.length);return e.set(r),e.set(t,r.length),e}function Ua(r){return r.sort((t,e)=>t.id.localeCompare(e.id))}function ht(r){return typeof r=="object"}function Da(r){if(ht(r)){if("error"in r&&r.error)throw new Error(r.error);if("detail"in r&&r.detail)throw new Error(r.detail)}}function gt(...r){return r.map(t=>t.replace(/(^\/+|\/+$)/g,"")).join("/")}function ur(r){return r.replace(/\/$/,"")}function Ut(r){return r.reduce((t,e)=>t+e.amount,0)}function qa(r){return pe.fromEncodedRequest(r)}class Hi{get value(){return this._value}set value(t){this._value=t}get next(){return this._next}set next(t){this._next=t}constructor(t){this._value=t,this._next=null}}class $i{get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}set size(t){this._size=t}constructor(){this._first=null,this._last=null,this._size=0}enqueue(t){const e=new Hi(t);return this._size===0||!this._last?(this._first=e,this._last=e):(this._last.next=e,this._last=e),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const t=this._first;return this._first=t.next,t.next=null,this._size--,t.value}}function lr(r){return r.map(t=>{const e={...t};return delete e.dleq,e})}function Fa(r){const t=ve(r.id),e=/^[a-fA-F0-9]+$/.test(r.id),n=e?U(r.id)[0]:0;return nn(r.keys,{expiry:r.final_expiry,input_fee_ppk:r.input_fee_ppk,unit:r.unit,versionByte:n,isDeprecatedBase64:t&&!e})===r.id}function Ha(r,t){const e=(t??[]).map(s=>typeof s=="string"?s:s.id),n=[];for(const s of r){let i;try{i=U(s.id)}catch{n.push(s);continue}if(i[0]===0)n.push(s);else if(i[0]===1){if(!e)throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");const o=e.filter(c=>s.id===c.slice(0,s.id.length));if(o.length>1)throw new Error(`Short keyset ID ${s.id} is ambiguous.`);if(o.length===0)throw new Error(`Couldn't map short keyset ID ${s.id} to any known keysets of the current Mint`);s.id=o[0],n.push(s)}else throw new Error(`Unknown keyset ID version: ${i[0]}`)}return n}function hr(r,t){if(r.dleq==null)return!1;const e={e:U(r.dleq.e),s:U(r.dleq.s),r:ye(r.dleq.r??"00")};if(!cr(r.amount,t.keys))throw new Error(`Undefined key for amount ${r.amount} in keyset ${t.id}`);const n=t.keys[r.amount];return ii(new TextEncoder().encode(r.secret),e,Bt(r.C),Bt(n))}function $a(...r){const t=r.reduce((s,i)=>s+i.length,0),e=new Uint8Array(t);let n=0;for(let s=0;s<r.length;s++)e.set(r[s],n),n=n+r[s].length;return e}function Wa(r){const t=new TextEncoder,e=Ui(r),n=bn(e),s=t.encode("craw"),i=t.encode("B");return $a(s,i,n)}function ja(r){const t=new TextDecoder,e=t.decode(r.slice(0,4)),n=t.decode(new Uint8Array([r[4]]));if(e!=="craw"||n!=="B")throw new Error("not a valid binary token");const s=r.slice(5),i=vn(s);return Di(i)}function Wi(r){return r.reduce((t,e)=>t+e,0)}function fr(r,t){if(r===t)return!0;if(r==null||t==null||typeof r!="object"||typeof t!="object")return!1;if(Array.isArray(r)&&Array.isArray(t))return r.length!==t.length?!1:r.every((s,i)=>fr(s,t[i]));if(Array.isArray(r)||Array.isArray(t))return!1;const e=Object.keys(r),n=Object.keys(t);return e.length!==n.length?!1:e.every(s=>n.includes(s)&&fr(r[s],t[s]))}function ji(r){return["web+cashu://","cashu://","cashu:","cashu"].forEach(e=>{r.startsWith(e)&&(r=r.slice(e.length))}),r}function Vi(r){return/^ln[a-z]{2,}[1-9][0-9]*(?:[mun]|0p)?1/i.test(r)}class Qt{constructor(){this.connectionMap=new Map}static getInstance(){return Qt.instance||(Qt.instance=new Qt),Qt.instance}getConnection(t,e){const n=this.connectionMap.get(t);if(n)return e&&n.setLogger(e),n;const s=new Gi(t,e);return this.connectionMap.set(t,s),s}}class Gi{constructor(t,e){this.subListeners={},this.rpcListeners={},this.rpcId=0,this.onCloseCallbacks=[],this._WS=po(),this.url=new URL(t),this.messageQueue=new $i,this._logger=e??X}setLogger(t){this._logger=t}connect(t=1e4){return this.connectionPromise?this.connectionPromise:(this.connectionPromise=new Promise((e,n)=>{let s=!1,i=!1,o=null;const c=l=>{i||(i=!0,o&&clearTimeout(o),l())},a=()=>{if(this.ws){try{this.ws.onopen=null,this.ws.onerror=null,this.ws.onmessage=null,this.ws.onclose=null}catch{}try{this.ws.close()}catch{}this.ws=void 0,this.stopMessageHandling()}},u=l=>{this.connectionPromise=void 0,a();const h=l instanceof Error?l:new Error(String(l));this.failPendingRpc(h),c(()=>n(h))};try{this.ws=new this._WS(this.url.toString())}catch(l){u(l);return}o=setTimeout(()=>{u(new Error(`WebSocket connect timeout after ${t}ms`))},t),this.ws.onopen=()=>{s=!0,c(e)},this.ws.onerror=l=>{if(!s){u(new Error("Failed to open WebSocket"));return}this._logger.error("WebSocket error after open",{ev:l})},this.ws.onmessage=l=>{this.messageQueue.enqueue(l.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMessage.bind(this),0))},this.ws.onclose=l=>{if(this.connectionPromise=void 0,!s){const w=l?.reason?`, ${l.reason}`:"";u(new Error(`WebSocket closed before open (code ${l?.code??0}${w})`));return}this.stopMessageHandling();const h=l?.reason?`, ${l.reason}`:"",f=l?.code??0;!(typeof l.wasClean=="boolean"?l.wasClean:!0)||f!==1e3&&f!==1001?this.failPendingRpc(new Error(`WebSocket closed (code ${f}${h})`)):this.rpcListeners={},this.onCloseCallbacks.forEach(w=>w(l))}}),this.connectionPromise)}sendRequest(t,e){if(this.ws?.readyState!==this._WS.OPEN){if(t==="unsubscribe")return;throw this._logger.error("Attempted sendRequest, but socket was not open"),new Error("Socket not open")}const n=this.rpcId;this.rpcId++,this.sendRpcMessage(t,e,n)}closeSubscription(t){this.ws?.send(JSON.stringify(["CLOSE",t]))}addSubListener(t,e){(this.subListeners[t]=this.subListeners[t]||[]).push(e)}stopMessageHandling(){for(this.handlingInterval&&(clearInterval(this.handlingInterval),this.handlingInterval=void 0);this.messageQueue.size>0;)this.messageQueue.dequeue()}failPendingRpc(t){const e=this.rpcListeners;this.rpcListeners={};for(const n of Object.keys(e))try{e[n].errorCallback(t)}catch{}}sendRpcMessage(t,e,n){if(this.ws?.readyState!==this._WS.OPEN)throw new Error("Socket not open");const s=JSON.stringify({jsonrpc:"2.0",method:t,params:e,id:n});try{this.ws.send(s)}catch(i){this._logger.error("WebSocket send failed",{e:i}),this.connectionPromise=void 0;try{this.ws.close()}catch{}this.ws=void 0,this.stopMessageHandling();const o=i instanceof Error?i:new Error(String(i));throw this.failPendingRpc(o),o}}addRpcListener(t,e,n){this.rpcListeners[n]={callback:t,errorCallback:e}}removeRpcListener(t){delete this.rpcListeners[t]}removeListener(t,e){if(this.subListeners[t]){if(this.subListeners[t].length===1){delete this.subListeners[t];return}this.subListeners[t]=this.subListeners[t].filter(n=>n!==e)}}async ensureConnection(t){this.ws?.readyState!==this._WS.OPEN&&await this.connect(t)}handleNextMessage(){if(this.messageQueue.size===0){this.handlingInterval&&(clearInterval(this.handlingInterval),this.handlingInterval=void 0);return}const t=this.messageQueue.dequeue();try{const e=JSON.parse(t);if("result"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].callback(),this.removeRpcListener(e.id));else if("error"in e&&e.id!=null)this.rpcListeners[e.id]&&(this.rpcListeners[e.id].errorCallback(new Error(e.error.message)),this.removeRpcListener(e.id));else if("method"in e&&!("id"in e)){const n=e.params?.subId;if(!n)return;if(this.subListeners[n]?.length>0){const s=e;this.subListeners[n].forEach(i=>{try{i(s.params?.payload)}catch(o){this._logger.error("Subscription handler threw",{e:o})}})}}}catch(e){this._logger.error("Error doing handleNextMessage",{e})}}createSubscription(t,e,n){if(this.ws?.readyState!==this._WS.OPEN)throw this._logger.error("Attempted createSubscription, but socket was not open"),new Error("Socket is not open");const s=(Math.random()+1).toString(36).substring(7),i=this.rpcId;this.addRpcListener(()=>{this.addSubListener(s,e)},n,i);try{this.sendRequest("subscribe",{...t,subId:s})}catch(o){throw this.removeRpcListener(i),o}return s}cancelSubscription(t,e,n){if(this.removeListener(t,e),this.ws?.readyState!==this._WS.OPEN){this._logger.info("Socket not open, removed listener locally {subId}",{subId:t});return}const s=this.rpcId;this.rpcId++,this.addRpcListener(()=>{this._logger.info("Unsubscribed {subId}",{subId:t})},n||(i=>this._logger.error("Unsubscribe failed",{e:i})),s);try{this.sendRpcMessage("unsubscribe",{subId:t},s)}catch(i){throw this.removeRpcListener(s),i}}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){if(this.ws){try{this.ws.close()}catch{}this.ws=void 0}this.connectionPromise=void 0,this.stopMessageHandling()}onClose(t){this.onCloseCallbacks.push(t)}}const rn={UNPAID:"UNPAID",PAID:"PAID",ISSUED:"ISSUED"},Zt={UNPAID:"UNPAID",PENDING:"PENDING",PAID:"PAID"},sn={UNSPENT:"UNSPENT",PENDING:"PENDING",SPENT:"SPENT"};function dr(r,t){return r.state||(t.warn("Field 'state' not found in Melt quote response. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof r.paid=="boolean"&&(r.state=r.paid?Zt.PAID:Zt.UNPAID)),r}function zi(r,t){return r.state||(t.warn("Field 'state' not found in Mint quote response. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof r.paid=="boolean"&&(r.state=r.paid?rn.PAID:rn.UNPAID)),r}function Va(r,t){return Array.isArray(r?.contact)&&r?.contact.length>0&&(r.contact=r.contact.map(e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="string"&&typeof e[1]=="string"?(t.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:e[0],info:e[1]}):e)),r}class me{constructor(t){this._mintInfo=t;const e=this.toEndpoints(t?.nuts?.[22]?.protected_endpoints);this._protected22=this.buildIndex(e);const n=this.toEndpoints(t?.nuts?.[21]?.protected_endpoints);this._protected21=this.buildIndex(n)}isSupported(t){switch(t){case 4:case 5:return this.checkMintMelt(t);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(t);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}requiresBlindAuthToken(t,e){return this.matchesProtected(this._protected22,t,e)}requiresClearAuthToken(t,e){return this.matchesProtected(this._protected21,t,e)}matchesProtected(t,e,n){if(!t)return!1;const s=`${e} ${n}`,i=t.cache[s];if(typeof i=="boolean")return i;const o=t.exact.some(u=>u.method===e&&u.path===n),c=o?!1:t.prefix.some(u=>u.method===e&&n.startsWith(u.path)),a=o||c;return t.cache[s]=a,a}checkGenericNut(t){return this._mintInfo.nuts[t]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(t){const e=this._mintInfo.nuts[t];return e&&e.methods.length>0&&!e.disabled?{disabled:!1,params:e.methods}:{disabled:!0,params:e?.methods??[]}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}toEndpoints(t){if(!Array.isArray(t))return[];const e=[];for(const n of t)if(n&&typeof n=="object"){const s=n,i=s.method,o=s.path;if(typeof i=="string"&&typeof o=="string"){const c=i.toUpperCase();(c==="GET"||c==="POST")&&e.push({method:c,path:o})}}return e}buildIndex(t){if(!t||t.length===0)return;const e=[],n=[];for(const i of t){let o=i.path;o.startsWith("^")&&(o=o.slice(1)),o.endsWith("$")&&(o=o.slice(0,-1)),o.endsWith(".*")?n.push({method:i.method,path:o.slice(0,-2)}):e.push({method:i.method,path:o})}return{cache:{},exact:e,prefix:n}}get cache(){return this._mintInfo}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}get supportsBolt12Description(){return this.supportsNut04Description("bolt12")}supportsNut04Description(t,e){return this._mintInfo.nuts[4]?.methods.some(n=>n.method===t&&(e?n.unit===e:!0)&&(n.options?.description===!0||n.description===!0))}supportsAmountless(t="bolt11",e="sat"){const n=this._mintInfo?.nuts?.[5]?.methods??[];return Array.isArray(n)?n.some(s=>s.method===t&&s.unit===e&&s.options?.amountless===!0):!1}}class on{constructor(t,e){this.tokenListeners=[],this.discoveryUrl=t,this.logger=e?.logger??X,this.clientId=e?.clientId??"cashu-client",this.scope=e?.scope??"openid",this.onTokens=e?.onTokens}static fromMintInfo(t,e){const n=t?.nuts?.["21"];if(!n?.openid_discovery)throw new Error("OIDCAuth: mint does not advertise NUT-21 openid_discovery");const s=e?.clientId??n.client_id??"cashu-client";return new on(n.openid_discovery,{...e,clientId:s})}setClient(t){this.clientId=t}setScope(t){this.scope=t??"openid"}addTokenListener(t){this.tokenListeners.push(t)}async loadConfig(){if(this.config)return this.config;const t=await fetch(this.discoveryUrl,{method:"GET",headers:{Accept:"application/json"}}),e=await t.text();let n;try{n=e?JSON.parse(e):void 0}catch(i){this.logger.warn("OIDCAuth: bad discovery JSON",{err:i})}if(!t.ok||!n)throw new Error("OIDCAuth: invalid discovery document");const s=n;if(typeof s.token_endpoint!="string"||s.token_endpoint.length===0)throw new Error("OIDCAuth: invalid discovery document, missing token_endpoint");return this.config=s,s}generatePKCE(){const t=yt(48),e=fn(t),n=N.fromString(e),s=Z(n),i=fn(s);return{verifier:e,challenge:i}}async buildAuthCodeUrl(t){const e=await this.loadConfig(),n=t.scope??this.scope,s=new URLSearchParams({response_type:"code",client_id:this.clientId,redirect_uri:t.redirectUri,scope:n,code_challenge_method:t.codeChallengeMethod??"S256",code_challenge:t.codeChallenge});if(t.state&&s.set("state",t.state),!e.authorization_endpoint)throw new Error("OIDCAuth: discovery lacks authorization_endpoint");return`${e.authorization_endpoint}?${s.toString()}`}async exchangeAuthCode(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"authorization_code",code:t.code,redirect_uri:t.redirectUri,client_id:this.clientId,code_verifier:t.codeVerifier}),s=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(s),s}async deviceStart(){const e=(await this.loadConfig()).device_authorization_endpoint;if(!e)throw new Error("OIDCAuth: provider lacks device_authorization_endpoint");const n=this.toForm({client_id:this.clientId,scope:this.scope});return this.postFormStrict(e,n)}async devicePoll(t,e=5){const n=await this.loadConfig();let s=Math.max(1,e);for(;;){await this.sleep(s*1e3);const i=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:t,client_id:this.clientId}),o=await this.postFormLoose(n.token_endpoint,i);if(o.access_token)return this.handleTokens(o),o;const c=(o.error??"").toString();if(c==="authorization_pending")continue;if(c==="slow_down"){s=Math.max(s+5,s*2);continue}const a=o.error_description||c||"device authorization failed";throw new Error(`OIDCAuth: ${a}`)}}async startDeviceAuth(t=5){const e=await this.deviceStart(),n=Math.max(e.interval??1,t);let s=!1;return{...e,poll:async()=>{const c=await this.loadConfig();let a=Math.max(1,n);for(;;){if(s)throw new Error("OIDCAuth: device polling cancelled");await this.sleep(a*1e3);const u=this.toForm({grant_type:"urn:ietf:params:oauth:grant-type:device_code",device_code:e.device_code,client_id:this.clientId}),l=await this.postFormLoose(c.token_endpoint,u);if(l.access_token)return this.handleTokens(l),l;const h=(l.error??"").toString();if(h==="authorization_pending")continue;if(h==="slow_down"){a=Math.max(a+5,a*2);continue}const f=l.error_description||h||"device authorization failed";throw new Error(`OIDCAuth: ${f}`)}},cancel:()=>{s=!0}}}async refresh(t){const e=await this.loadConfig(),n=this.toForm({grant_type:"refresh_token",refresh_token:t,client_id:this.clientId}),s=await this.postFormStrict(e.token_endpoint,n);return this.handleTokens(s),s}async passwordGrant(t,e){const n=await this.loadConfig(),s=this.toForm({grant_type:"password",client_id:this.clientId,username:t,password:e,scope:this.scope}),i=await this.postFormStrict(n.token_endpoint,s);return this.handleTokens(i),i}handleTokens(t){if(!t.access_token){const e=t.error_description||t.error||"token response missing access_token";throw new Error(`OIDCAuth: ${e}`)}queueMicrotask(()=>Xt(this.onTokens,t,this.logger,{where:"OIDCAuth.handleTokens"}));for(const e of this.tokenListeners)queueMicrotask(()=>Xt(e,t,this.logger,{where:"OIDCAuth.handleTokens.listener"}))}toForm(t){const e=n=>encodeURIComponent(n).replace(/%20/g,"+");return Object.entries(t).map(([n,s])=>`${e(n)}=${e(s)}`).join("&")}async postFormStrict(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const n=await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e}),s=await n.text();let i;try{i=s?JSON.parse(s):void 0}catch(o){this.logger.warn("OIDCAuth: bad JSON (strict)",{err:o})}if(!n.ok){const o=i??{},c=o.error_description||o.error||`HTTP ${n.status}`;throw new Error(`OIDCAuth: ${c}`)}return this.logger.debug("OIDCAuth Response",{json:i}),i??{}}catch(n){throw this.logger.error("OIDCAuth: postFormStrict failed",{err:n}),n}}async postFormLoose(t,e){try{this.logger.debug("OIDCAuth Request",{formBody:e});const s=await(await fetch(t,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:e})).text();let i;try{i=s?JSON.parse(s):void 0}catch(o){this.logger.warn("OIDCAuth: bad JSON (loose)",{err:o})}return this.logger.debug("OIDCAuth Response",{json:i}),i??{}}catch(n){return this.logger.error("OIDCAuth: postFormLoose network error",{err:n}),{error:"network_error",error_description:String(n)}}}sleep(t){return new Promise(e=>setTimeout(e,t))}}class cn{constructor(t,e){this._mintUrl=ur(t),this._request=e?.customRequest??Ar,this._authProvider=e?.authProvider,this._logger=e?.logger??X,ho(this._logger)}get mintUrl(){return this._mintUrl}async oidcAuth(t){const e=(await this.getLazyMintInfo()).nuts[21];if(!e?.openid_discovery)throw new Error("Mint: no NUT-21 openid_discovery");return new on(e.openid_discovery,{...t,clientId:t?.clientId??e.client_id??"cashu-client"})}async getInfo(t){const n=await(t??this._request)({endpoint:gt(this._mintUrl,"/v1/info")});return Va(n,this._logger)}async getLazyMintInfo(){if(this._mintInfo)return this._mintInfo;const t=await this.getInfo();return this._mintInfo=new me(t),this._mintInfo}async swap(t,e){const n=await this.requestWithAuth("POST","/v1/swap",{requestBody:t},e);if(!ht(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"swap"}),new Error("Invalid response from mint");return n}async createMintQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/quote/bolt11",{requestBody:t},e);return zi(n,this._logger)}async createMintQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/mint/quote/bolt12",{requestBody:t},e)}async checkMintQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/mint/quote/bolt11/${t}`,{},e);return zi(n,this._logger)}async checkMintQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/mint/quote/bolt12/${t}`,{},e)}async mintBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt11",{requestBody:t},e);if(!ht(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"mintBolt11"}),new Error("Invalid response from mint");return n}async mintBolt12(t,e){const n=await this.requestWithAuth("POST","/v1/mint/bolt12",{requestBody:t},e);if(!ht(n)||!Array.isArray(n?.signatures))throw this._logger.error("Invalid response from mint...",{data:n,op:"mintBolt12"}),new Error("Invalid response from mint");return n}async createMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("POST","/v1/melt/quote/bolt11",{requestBody:t},e),s=dr(n,this._logger);if(!ht(s)||typeof s?.amount!="number"||typeof s?.fee_reserve!="number"||typeof s?.quote!="string")throw this._logger.error("Invalid response from mint...",{data:s,op:"createMeltQuoteBolt11"}),new Error("Invalid response from mint");return s}async createMeltQuoteBolt12(t,e){return await this.requestWithAuth("POST","/v1/melt/quote/bolt12",{requestBody:t},e)}async checkMeltQuoteBolt11(t,e){const n=await this.requestWithAuth("GET",`/v1/melt/quote/bolt11/${t}`,{},e),s=dr(n,this._logger);if(!ht(s)||typeof s?.amount!="number"||typeof s?.fee_reserve!="number"||typeof s?.quote!="string"||typeof s?.state!="string"||!Object.values(Zt).includes(s.state))throw this._logger.error("Invalid response from mint...",{data:s,op:"checkMeltQuoteBolt11"}),new Error("Invalid response from mint");return s}async checkMeltQuoteBolt12(t,e){return await this.requestWithAuth("GET",`/v1/melt/quote/bolt12/${t}`,{},e)}async melt(t,e,n){const s={...n?.preferAsync?{Prefer:"respond-async"}:{}};hn(!this.isValidMethodString(t),`Invalid melt method: ${t}`,this._logger);const i=await this.requestWithAuth("POST",`/v1/melt/${t}`,{requestBody:e,headers:s},n?.customRequest);if(!ht(i))throw this._logger.error("Invalid response from mint...",{data:i,op:"melt"}),new Error("Invalid response from mint");return i}async meltBolt11(t,e){const n=await this.melt("bolt11",t,e),s=dr(n,this._logger);if(!ht(s)||typeof s?.state!="string"||!Object.values(Zt).includes(s.state))throw this._logger.error("Invalid response from mint...",{data:s,op:"meltBolt11"}),new Error("Invalid response from mint");return s}async meltBolt12(t,e){return this.melt("bolt12",t,e)}async check(t,e){const n=await this.requestWithAuth("POST","/v1/checkstate",{requestBody:t},e);if(!ht(n)||!Array.isArray(n?.states))throw this._logger.error("Invalid response from mint...",{data:n,op:"check"}),new Error("Invalid response from mint");return n}async getKeys(t,e,n){const s=e||this._mintUrl;t&&(t=t.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(n??this._request)({endpoint:t?gt(s,"/v1/keys",t):gt(s,"/v1/keys")});if(!ht(o)||!Array.isArray(o.keysets))throw this._logger.error("Invalid response from mint...",{data:o,op:"getKeys"}),new Error("Invalid response from mint");return o}async getKeySets(t){return(t??this._request)({endpoint:gt(this._mintUrl,"/v1/keysets")})}async restore(t,e){const s=await(e??this._request)({endpoint:gt(this._mintUrl,"/v1/restore"),method:"POST",requestBody:t});if(!ht(s)||!Array.isArray(s?.outputs)||!Array.isArray(s?.signatures))throw this._logger.error("Invalid response from mint...",{data:s,op:"restore"}),new Error("Invalid response from mint");return s}async connectWebSocket(){try{const t=new URL(this._mintUrl),e="v1/ws";t.pathname.endsWith("/")?t.pathname+=e:t.pathname+="/"+e,t.protocol=t.protocol==="https:"?"wss:":"ws:";const n=t.toString();this.ws||(this.ws=Qt.getInstance().getConnection(n,this._logger)),await this.ws.ensureConnection()}catch(t){this._logger.error("Failed to connect to WebSocket...",{e:t});try{this.ws?.close()}catch{}throw this.ws=void 0,new Error("Failed to connect to WebSocket...")}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}async handleClearAuth(t,e){if(!(!this._authProvider||!(await this.getLazyMintInfo()).requiresClearAuthToken(t,e)))return this._logger.error("Clear Authentication Token...",{cat:this._authProvider.getCAT()}),this._authProvider.getCAT()}async handleBlindAuth(t,e){if(!this._authProvider||!(await this.getLazyMintInfo()).requiresBlindAuthToken(t,e))return;const s=await this._authProvider.getBlindAuthToken({method:t,path:e});return this._logger.error("Blind Authentication Token...",{bat:s}),s}async requestWithAuth(t,e,n={},s){const i=s??this._request,o=await this.handleBlindAuth(t,e),c=await this.handleClearAuth(t,e),a={...n.headers??{},...o?{"Blind-auth":o}:{},...c?{"Clear-auth":c}:{}};return i({...n,endpoint:gt(this._mintUrl,e),method:t,headers:a})}isValidMethodString(t){return!!(typeof t=="string"&&/^[a-z0-9_-]+$/.test(t))}}class Yt{constructor(t,e,n,s,i){this._keys={},this._id=t,this._unit=e,this._active=n,this._input_fee_ppk=s,this._final_expiry=i}get id(){return this._id}get unit(){return this._unit}get isActive(){return this._active}get fee(){return this._input_fee_ppk??0}get expiry(){return this._final_expiry}get hasKeys(){return Object.keys(this._keys).length>0}get hasHexId(){return Nt(this._id)}get keys(){return this._keys}set keys(t){this._keys=t}get active(){return this.isActive}get input_fee_ppk(){return this.fee}get final_expiry(){return this.expiry}toMintKeyset(){return{id:this._id,unit:this._unit,active:this._active,input_fee_ppk:this._input_fee_ppk,final_expiry:this._final_expiry}}toMintKeys(){return this.hasKeys?{id:this._id,unit:this._unit,active:this._active,input_fee_ppk:this._input_fee_ppk,final_expiry:this._final_expiry,keys:this._keys}:null}verify(){return this.hasKeys?Yt.verifyKeysetId(this.toMintKeys()):!1}static verifyKeysetId(t){if(!t.keys||Object.keys(t.keys).length===0)return!1;const e=ve(t.id)&&!Nt(t.id),n=Nt(t.id)?U(t.id)[0]:0;return nn(t.keys,{input_fee_ppk:t.input_fee_ppk,expiry:t.final_expiry,unit:t.unit,versionByte:n,isDeprecatedBase64:e})===t.id}static fromMintApi(t,e){const n=new Yt(t.id,t.unit,t.active,t.input_fee_ppk,t.final_expiry);if(e){if(e.id!==t.id)throw new Error(`Mismatched keyset ids: meta=${t.id}, keys=${e.id}`);if(e.unit!==t.unit)throw new Error(`Mismatched keyset units: meta=${t.unit}, keys=${e.unit}`);if(e.final_expiry!==void 0&&t.final_expiry!==void 0&&e.final_expiry!==t.final_expiry)throw new Error(`Mismatched keyset expiry for id=${t.id}`);n.keys=e.keys}return n}}class kt{constructor(t,e,n,s){if(this.keysets={},this.mint=typeof t=="string"?new cn(t):t,this.unit=e,n&&s){const i=Array.isArray(s)?s:[s];this.buildKeychain(n,i),this.getCheapestKeyset()}}static fromCache(t,e){const n=new kt(t,e.unit);return n.loadFromCache(e),n}static mintToCacheDTO(t,e,n,s){const i=new Map(s.map(c=>[c.id,c]));return{keysets:n.map(c=>{const a=i.get(c.id),u={...c};return a&&(u.keys=a.keys),u}),unit:t,mintUrl:e}}static cacheToMintDTO(t){const e=t.keysets.map(s=>({id:s.id,unit:s.unit,active:s.active,input_fee_ppk:s.input_fee_ppk,final_expiry:s.final_expiry})),n=t.keysets.filter(s=>!!s.keys).map(s=>({id:s.id,unit:s.unit,active:s.active,input_fee_ppk:s.input_fee_ppk,final_expiry:s.final_expiry,keys:s.keys}));return{keysets:e,keys:n}}async init(t){if(Object.keys(this.keysets).length>0&&!t)return;const[e,n]=await Promise.all([this.mint.getKeySets(),this.mint.getKeys()]);this.buildKeychain(e.keysets,n.keysets),this.getCheapestKeyset()}loadFromCache(t){if(t.unit!==this.unit)throw new Error(`KeyChain unit mismatch in cache, expected '${this.unit}', got '${t.unit}' from ${t.mintUrl}`);const{keysets:e,keys:n}=kt.cacheToMintDTO(t);this.buildKeychain(e,n),this.getCheapestKeyset()}buildKeychain(t,e){this.keysets={};const n=t.filter(i=>i.unit===this.unit);if(!n.length)throw new Error(`No Keysets found for unit: ${this.unit}`);const s=new Map(e.filter(i=>i.unit===this.unit).map(i=>[i.id,i]));for(const i of n){let o;if(i.active&&Nt(i.id)){const c=s.get(i.id);o=Yt.fromMintApi(i,c)}else o=Yt.fromMintApi(i);if(o.hasKeys&&!o.verify())throw new Error(`Keyset verification failed for ID ${o.id}`);this.keysets[o.id]=o}}getKeyset(t){const e=t?this.keysets[t]:this.getCheapestKeyset();if(!e)throw new Error(`Keyset '${t}' not found`);return e}getCheapestKeyset(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");const t=Object.values(this.keysets).filter(e=>e.isActive&&e.hasHexId&&e.hasKeys);if(t.length===0)throw new Error("No active keyset found");return t.sort((e,n)=>e.fee-n.fee)[0]}getKeysets(){if(Object.keys(this.keysets).length===0)throw new Error("KeyChain not initialized");return Object.values(this.keysets)}getAllKeys(){return this.getKeysets().map(t=>t.toMintKeys()).filter(t=>t!==null)}getAllKeysetIds(){return this.getKeysets().map(t=>t.id)}get cache(){const t=this.getKeysets(),e=t.map(s=>s.toMintKeyset()),n=t.map(s=>s.toMintKeys()).filter(s=>s!==null);return kt.mintToCacheDTO(this.unit,this.mint.mintUrl,e,n)}getCache(){const t=this.cache,{keysets:e,keys:n}=kt.cacheToMintDTO(t);return{keysets:e,keys:n,unit:t.unit,mintUrl:t.mintUrl}}}class gr{constructor(t,e,n){this.amount=t,this.B_=e,this.id=n}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}const Ga=new Set(["locktime","pubkeys","n_sigs","refund","n_sigs_refund"]);function Qi(r){if(!r||typeof r!="string")throw new Error("tag key must be a non empty string");if(Ga.has(r))throw new Error(`additionalTags must not use reserved key "${r}"`)}const Zi=1024,pr=new WeakMap;function za(r,t){t&&pr.set(r,t)}function Qa(r){const t=pr.get(r);if(t)return pr.delete(r),t}class ct{constructor(t,e,n){this.secret=n,this.blindingFactor=e,this.blindedMessage=t}toProof(t,e){let n;t.dleq&&(n={s:U(t.dleq.s),e:U(t.dleq.e),r:this.blindingFactor});const s={id:t.id,amount:t.amount,C_:Bt(t.C_)},i=Bt(e.keys[t.amount]),o=Ms(s,this.blindingFactor,this.secret,i),c={...Ks(o),...n&&{dleq:{s:H(n.s),e:H(n.e),r:Je(n.r??BigInt(0))}}},a=Qa(this);return a&&(c.p2pk_e=a),c}static createP2PKData(t,e,n,s){return vt(e,n.keys,s).map(o=>this.createSingleP2PKData(t,o,n.id))}static createSingleP2PKData(t,e,n){const s=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey],i=t.refundKeys??[],o=Math.max(1,Math.min(t.requiredSignatures??1,s.length)),c=Math.max(1,Math.min(t.requiredRefundSignatures??1,i.length||1));if(s.length===0)throw new Error("P2PK requires at least one pubkey");const a=typeof t.hashlock=="string"&&t.hashlock.length>0;let u=a?t.hashlock:s[0],l=a?s:s.slice(1),h=i,f;if(t.blindKeys){const Y=[...s,...i],{blinded:$,Ehex:L}=$s(Y,n);a?l=$.slice(0,s.length):(u=$[0],l=$.slice(1,s.length)),h=$.slice(s.length),f=L}const d=[],y=t.locktime??NaN;if(Number.isSafeInteger(y)&&y>=0&&d.push(["locktime",String(y)]),l.length>0&&(d.push(["pubkeys",...l]),o>1&&d.push(["n_sigs",String(o)])),h.length>0&&(d.push(["refund",...h]),c>1&&d.push(["n_sigs_refund",String(c)])),t.sigFlag=="SIG_ALL"&&d.push(["sigflag","SIG_ALL"]),t.additionalTags?.length){const Y=t.additionalTags.map(([$,...L])=>(Qi($),[$,...L.map(String)]));d.push(...Y)}const b=[a?"HTLC":"P2PK",{nonce:H(yt(32)),data:u,tags:d}],P=JSON.stringify(b),K=[...P].length;if(K>Zi)throw new Error(`Secret too long (${K} characters), maximum is ${Zi}`);const B=new TextEncoder().encode(P),{r:q,B_:V}=ce(B),F=new ct(new gr(e,V,n).getSerializedBlindedMessage(),q,B);return t.blindKeys&&f&&za(F,f),F}static createRandomData(t,e,n){return vt(t,e.keys,n).map(i=>this.createSingleRandomData(i,e.id))}static createSingleRandomData(t,e){const n=H(yt(32)),s=new TextEncoder().encode(n),{r:i,B_:o}=ce(s);return new ct(new gr(t,o,e).getSerializedBlindedMessage(),i,s)}static createDeterministicData(t,e,n,s,i){return vt(t,s.keys,i).map((c,a)=>this.createSingleDeterministicData(c,e,n+a,s.id))}static createSingleDeterministicData(t,e,n,s){const i=ci(e,s,n),o=H(i),c=new TextEncoder().encode(o),a=N.toBigInt(ai(e,s,n)),{r:u,B_:l}=ce(c,a);return new ct(new gr(t,l,s).getSerializedBlindedMessage(),u,c)}static sumOutputAmounts(t){return t.reduce((e,n)=>e+n.blindedMessage.amount,0)}}function Yi(r){const t=r.toLowerCase();if(t.length===66&&(t.startsWith("02")||t.startsWith("03")))return t;if(t.length===64)return`02${t}`;throw new Error(`Invalid pubkey, expected 33 byte compressed or 32 byte x only, got length ${t.length}`)}function Za(r){return r instanceof Date?Math.floor(r.getTime()/1e3):r<1e12?Math.floor(r):Math.floor(r/1e3)}class yr{constructor(){this.lockSet=new Set,this.refundSet=new Set,this.extraTags=[]}addLockPubkey(t){const e=Array.isArray(t)?t:[t];for(const n of e)this.lockSet.add(Yi(n));return this}addRefundPubkey(t){const e=Array.isArray(t)?t:[t];for(const n of e)this.refundSet.add(Yi(n));return this}lockUntil(t){return this.locktime=Za(t),this}requireLockSignatures(t){return this.nSigs=Math.max(1,Math.trunc(t)),this}requireRefundSignatures(t){return this.nSigsRefund=Math.max(1,Math.trunc(t)),this}addTag(t,e){Qi(t);const n=e===void 0?[]:Array.isArray(e)?e:[e];return this.extraTags.push([t,...n.map(String)]),this}addTags(t){for(const[e,...n]of t)this.addTag(e,n);return this}blindKeys(){return this._blindKeys=!0,this}sigAll(){return this.sigFlag="SIG_ALL",this}addHashlock(t){return this.hashlock=t,this}toOptions(){const t=Array.from(this.lockSet),e=Array.from(this.refundSet);if(t.length===0)throw new Error("At least one lock pubkey is required");if(e.length>0&&this.locktime===void 0)throw new Error("Refund pubkeys require a locktime, add lockUntil(...) or remove refund keys");const n=t.length+e.length;if(n>10)throw new Error(`Too many pubkeys, ${n} provided, maximum allowed is 10 in total`);const s=this.nSigs?Math.min(Math.max(1,this.nSigs),t.length):void 0,i=this.nSigsRefund?Math.min(Math.max(1,this.nSigsRefund),Math.max(1,e.length)):void 0,c={pubkey:t.length===1?t[0]:t,...this.locktime!==void 0?{locktime:this.locktime}:{},...e.length?{refundKeys:e}:{},...s&&s>1?{requiredSignatures:s}:{},...i&&i>1?{requiredRefundSignatures:i}:{},...this.extraTags.length?{additionalTags:this.extraTags.slice()}:{},...this._blindKeys?{blindKeys:!0}:{},...this.sigFlag=="SIG_ALL"?{sigFlag:"SIG_ALL"}:{},...this.hashlock?{hashlock:this.hashlock}:{}};return ct.createSingleP2PKData(c,1,"deedbeef"),c}static fromOptions(t){const e=new yr,n=Array.isArray(t.pubkey)?t.pubkey:[t.pubkey];return e.addLockPubkey(n),t.locktime!==void 0&&e.lockUntil(t.locktime),t.refundKeys?.length&&e.addRefundPubkey(t.refundKeys),t.requiredSignatures!==void 0&&e.requireLockSignatures(t.requiredSignatures),t.requiredRefundSignatures!==void 0&&e.requireRefundSignatures(t.requiredRefundSignatures),t.additionalTags?.length&&e.addTags(t.additionalTags),t.blindKeys&&e.blindKeys(),t.sigFlag=="SIG_ALL"&&e.sigAll(),t.hashlock&&e.addHashlock(t.hashlock),e}}const Xi=(r,t,e,n=!1,s=!1,i=X)=>{const h=uo();let f=null,d=1/0,y=0,w=0;const b=_=>{try{return e.getKeyset(_.id).fee}catch(E){be(`Could not get fee. No keyset found for keyset id: ${_.id}`,i,{error:E,keychain:e.getKeysets()})}},P=(_,E)=>_-(n?Math.ceil(E/1e3):0),K=_=>{const E=[..._];for(let m=E.length-1;m>0;m--){const p=Math.floor(Math.random()*(m+1));[E[m],E[p]]=[E[p],E[m]]}return E},B=(_,E,m)=>{let p=0,v=_.length-1,S=null;for(;p<=v;){const C=Math.floor((p+v)/2),I=_[C].exFee;(m?I<=E:I>=E)?(S=C,m?p=C+1:v=C-1):m?v=C-1:p=C+1}return m?S:p<_.length?p:null},q=(_,E)=>{const m=E.exFee;let p=0,v=_.length;for(;p<v;){const S=Math.floor((p+v)/2);_[S].exFee<m?p=S+1:v=S}_.splice(p,0,E)},V=(_,E)=>P(_,E)<t?1/0:_+E/1e3-t;let F=0,Y=0;const $=r.map(_=>{const E=b(_),m=n?_.amount-E/1e3:_.amount,p={proof:_,exFee:m,ppkfee:E};return(!n||m>0)&&(F+=_.amount,Y+=E),p});let L=n?$.filter(_=>_.exFee>0):$;if(L.sort((_,E)=>_.exFee-E.exFee),L.length>0){let _;if(s){const E=B(L,t,!0);_=E!==null?E+1:0}else{const E=B(L,t,!1);if(E!==null){const m=L[E].exFee,p=B(L,m,!0);Er(p,"Unexpected null rightIndex in binary search",i),_=p+1}else _=L.length}for(let E=_;E<L.length;E++)F-=L[E].proof.amount,Y-=L[E].ppkfee;L=L.slice(0,_)}const ft=P(F,Y);if(t<=0||t>ft)return{keep:r,send:[]};const at=Math.min(Math.ceil(t*(1+0/100)),t+0,ft);for(let _=0;_<60;_++){const E=[];let m=0,p=0;for(const x of K(L)){const A=m+x.proof.amount,T=p+x.ppkfee,M=P(A,T);if(s&&M>t||(E.push(x),m=A,p=T,M>=t))break}const v=new Set(E),S=L.filter(x=>!v.has(x)),C=K(Array.from({length:E.length},(x,A)=>A)).slice(0,5e3);for(const x of C){const A=P(m,p);if(A===t||!s&&A>=t&&A<=at)break;const T=E[x],M=m-T.proof.amount,j=p-T.ppkfee,W=P(M,j),R=t-W,G=B(S,R,s);if(G!==null){const z=S[G];(!s||z.exFee>T.exFee)&&(R>=0||z.exFee<=T.exFee)&&(E[x]=z,m=M+z.proof.amount,p=j+z.ppkfee,S.splice(G,1),q(S,T))}}const I=V(m,p);if(I<d){i.debug(`selectProofsToSend: best solution found in trial #${_} - amount: ${m}, delta: ${I}`),f=[...E].sort((A,T)=>T.exFee-A.exFee),d=I,y=m,w=p;const x=[...f];for(;x.length>1&&d>0;){const A=x.pop(),T=m-A.proof.amount,M=p-A.ppkfee,j=V(T,M);if(j==1/0)break;j<d&&(f=[...x],d=j,y=T,w=M,m=T,p=M)}}if(f&&d<1/0){const x=P(y,w);if(x===t||!s&&x>=t&&x<=at)break}if(h.elapsed()>1e3){hn(s,"Proof selection took too long. Try again with a smaller proof set.",i),i.warn("Proof selection took too long. Returning best selection so far.");break}}if(f&&d<1/0){const _=f.map(p=>p.proof),E=new Set(_),m=r.filter(p=>!E.has(p));return i.info(`Proof selection took ${h.elapsed()}ms`),{keep:m,send:_}}return{keep:r,send:[]}};class Ya{constructor(t){if(this.next=new Map,this.locks=new Map,t)for(const[e,n]of Object.entries(t))this.next.set(e,n)}async withLock(t,e){const n=this.locks.get(t)??Promise.resolve();let s;const i=new Promise(c=>s=c),o=n.then(()=>i);this.locks.set(t,o);try{return await n,await e()}finally{s(),this.locks.get(t)===o&&this.locks.delete(t)}}async reserve(t,e){if(e<0)throw new Error("reserve called with negative count");return this.withLock(t,()=>{const n=this.next.get(t)??0;return e===0?{start:n,count:0}:(this.next.set(t,n+e),{start:n,count:e})})}async advanceToAtLeast(t,e){await this.withLock(t,()=>{const n=this.next.get(t)??0;e>n&&this.next.set(t,e)})}async setNext(t,e){await this.withLock(t,()=>{if(e<0)throw new Error("setNext: negative next not allowed");this.next.set(t,e)})}snapshot(){return Promise.resolve(Object.fromEntries(this.next.entries()))}}class Ji{constructor(t){this.wallet=t}send(t,e){return new to(this.wallet,t,e)}receive(t){return new eo(this.wallet,t)}mintBolt11(t,e){return new mr(this.wallet,"bolt11",t,e)}mintBolt12(t,e){return new mr(this.wallet,"bolt12",t,e)}meltBolt11(t,e){return new wr(this.wallet,"bolt11",t,e)}meltBolt12(t,e){return new wr(this.wallet,"bolt12",t,e)}}class to{constructor(t,e,n){this.wallet=t,this.amount=e,this.proofs=n,this.config={}}asRandom(t){return this.sendOT={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.sendOT={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.sendOT={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.sendOT={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.sendOT={type:"custom",data:t},this}keepAsRandom(t){return this.keepOT={type:"random",denominations:t},this}keepAsDeterministic(t=0,e){return this.keepOT={type:"deterministic",counter:t,denominations:e},this}keepAsP2PK(t,e){return this.keepOT={type:"p2pk",options:t,denominations:e},this}keepAsFactory(t,e){return this.keepOT={type:"factory",factory:t,denominations:e},this}keepAsCustom(t){return this.keepOT={type:"custom",data:t},this}includeFees(t=!0){return this.config.includeFees=t,this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}offlineExactOnly(t=!1){return this.offlineExact={requireDleq:t},this}offlineCloseMatch(t=!1){return this.offlineClose={requireDleq:t},this}async prepare(){const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.prepareSwapToSend(this.amount,this.proofs,this.config,t)}async run(){if((this.offlineExact||this.offlineClose)&&(this.sendOT||this.keepOT))throw new Error("Offline selection cannot be combined with custom output types. Remove send/keep output configuration, or use an online swap.");if(this.offlineExact)return this.config.privkey&&(this.proofs=this.wallet.signP2PKProofs(this.proofs,this.config.privkey)),this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!0,requireDleq:this.offlineExact.requireDleq});if(this.offlineClose)return this.config.privkey&&(this.proofs=this.wallet.signP2PKProofs(this.proofs,this.config.privkey)),this.wallet.sendOffline(this.amount,this.proofs,{includeFees:this.config.includeFees,exactMatch:!1,requireDleq:this.offlineClose.requireDleq});const t={send:this.sendOT??this.wallet.defaultOutputType(),...this.keepOT?{keep:this.keepOT}:{}};return this.wallet.send(this.amount,this.proofs,this.config,t)}}class eo{constructor(t,e){this.wallet=t,this.token=e,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}requireDleq(t=!0){return this.config.requireDleq=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async prepare(){return this.wallet.prepareSwapToReceive(this.token,this.config,this.outputType)}async run(){return this.wallet.receive(this.token,this.config,this.outputType)}}class mr{constructor(t,e,n,s){this.wallet=t,this.method=e,this.amount=n,this.quote=s,this.config={},this._hasPrivkey}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}proofsWeHave(t){return this.config.proofsWeHave=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}async run(){if(this.method==="bolt11"){const e=this.quote;if(typeof e!="string"&&e.pubkey&&!this.config.privkey)throw new Error("privkey is required for locked BOLT11 mint quotes");return this.wallet.mintProofsBolt11(this.amount,e,this.config,this.outputType)}const t=this.quote;if(!this.config.privkey)throw new Error("privkey is required for BOLT12 mint quotes");return this.wallet.mintProofsBolt12(this.amount,t,this.config.privkey,this.config,this.outputType)}}class wr{constructor(t,e,n,s){this.wallet=t,this.method=e,this.quote=n,this.proofs=s,this.config={}}asRandom(t){return this.outputType={type:"random",denominations:t},this}asDeterministic(t=0,e){return this.outputType={type:"deterministic",counter:t,denominations:e},this}asP2PK(t,e){return this.outputType={type:"p2pk",options:t,denominations:e},this}asFactory(t,e){return this.outputType={type:"factory",factory:t,denominations:e},this}asCustom(t){return this.outputType={type:"custom",data:t},this}keyset(t){return this.config.keysetId=t,this}privkey(t){return this.config.privkey=t,this}onCountersReserved(t){return this.config.onCountersReserved=t,this}onChangeOutputsCreated(t){return this.config.onChangeOutputsCreated=t,this}async prepare(){return await this.wallet.prepareMelt(this.method,this.quote,this.proofs,this.config,this.outputType)}async run(){const t=await this.wallet.prepareMelt(this.method,this.quote,this.proofs,this.config,this.outputType);return this.wallet.completeMelt(t,this.config.privkey)}}function Xa(r){const t=new WeakSet;try{return JSON.stringify(r,(e,n)=>{if(typeof n=="object"&&n!==null){if(t.has(n))return"[Circular]";t.add(n)}return n})}catch{return Object.prototype.toString.call(r)}}function no(r){if(r instanceof Error)return r;const t=typeof r=="string"?r:Xa(r),e=new Error(t);return e.cause=r,e}function ro(){const r=new Error("Aborted");return Object.defineProperty(r,"name",{value:"AbortError"}),r}function Dt(r){r&&Promise.resolve(r).then(t=>{try{t()}catch{}}).catch(()=>{})}class so{constructor(t){this.wallet=t,this.countersReservedHandlers=new Set,this.meltBlanksHandlers=new Set}withAbort(t,e){if(!t)return e;if(t.aborted)return e(),()=>{};const n=()=>e();return t.addEventListener("abort",n,{once:!0}),()=>{t.removeEventListener("abort",n),e()}}waitUntilPaid(t,e,n,s="Timeout waiting for paid"){return new Promise((i,o)=>{let c=null,a=null,u=!1;const l=f=>{u||(u=!0,Dt(c),a&&(clearTimeout(a),a=null),n?.signal&&n.signal.removeEventListener("abort",h),f&&o(no(f)))},h=()=>l(ro());if(n?.signal){if(n.signal.aborted)return h();n.signal.addEventListener("abort",h,{once:!0})}n?.timeoutMs&&n.timeoutMs>0&&(a=setTimeout(()=>l(new Error(s)),n.timeoutMs)),c=t(e,f=>{l(),i(f)},f=>l(f),{signal:n?.signal}),c.catch(f=>l(f))})}countersReserved(t,e){this.countersReservedHandlers.add(t);const n=()=>this.countersReservedHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitCountersReserved(t){for(const e of this.countersReservedHandlers)Xt(e,t,this.wallet.logger,{event:"countersReserved"})}meltBlanksCreated(t,e){this.meltBlanksHandlers.add(t);const n=()=>this.meltBlanksHandlers.delete(t);return this.withAbort(e?.signal,n)}_emitMeltBlanksCreated(t){for(const e of this.meltBlanksHandlers)Xt(e,t,this.wallet.logger,{event:"meltBlanksCreated"})}async mintQuoteUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=Array.from(new Set(t)),c=i.createSubscription({kind:"bolt11_mint_quote",filters:o},e,n),a=()=>i.cancelSubscription(c,e);return this.withAbort(s?.signal,a)}async mintQuotePaid(t,e,n,s){return this.mintQuoteUpdates([t],i=>{i.state===rn.PAID&&e(i)},n,s)}async meltQuoteUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=Array.from(new Set(t)),c=i.createSubscription({kind:"bolt11_melt_quote",filters:o},e,n),a=()=>i.cancelSubscription(c,e);return this.withAbort(s?.signal,a)}async meltQuotePaid(t,e,n,s){return this.meltQuoteUpdates([t],i=>{i.state===Zt.PAID&&e(i)},n,s)}async proofStateUpdates(t,e,n,s){await this.wallet.mint.connectWebSocket();const i=this.wallet.mint.webSocketConnection;if(!i)throw new Error("Failed to establish WebSocket connection.");const o=new TextEncoder,c={};for(const f of t){const d=Vt(o.encode(f.secret)).toHex(!0);c[d]=f}const a=Object.keys(c),u=f=>{e({...f,proof:c[f.Y]})},l=i.createSubscription({kind:"proof_state",filters:a},u,n),h=()=>i.cancelSubscription(l,u);return this.withAbort(s?.signal,h)}onceMintPaid(t,e){return this.waitUntilPaid(this.mintQuotePaid.bind(this),t,e,"Timeout waiting for mint paid")}onceAnyMintPaid(t,e){return new Promise((n,s)=>{const i=Array.from(new Set(t)),o=new Map;let c=null,a=null,u=!1,l=!1;const h=d=>{if(!l){l=!0;for(const y of o.values())Dt(y);o.clear(),c&&(clearTimeout(c),c=null),e?.signal&&e.signal.removeEventListener("abort",f),d&&s(no(d))}},f=()=>h(ro());if(e?.signal){if(e.signal.aborted)return f();e.signal.addEventListener("abort",f,{once:!0})}if(e?.timeoutMs&&e.timeoutMs>0&&(c=setTimeout(()=>h(new Error("Timeout waiting for any mint paid")),e.timeoutMs)),i.length===0)return h(new Error("No quote ids provided"));for(const d of i){const y=this.mintQuotePaid(d,w=>{h(),n({id:d,quote:w})},w=>{if(e?.failOnError){h(w);return}a=w;const b=o.get(d);b&&(Dt(b),o.delete(d)),u&&o.size===0&&h(a??new Error("No subscriptions remaining"))});o.set(d,y),y.catch(w=>{if(e?.failOnError){h(w);return}a=w;const b=o.get(d);b&&(Dt(b),o.delete(d)),u&&o.size===0&&h(a??new Error("No subscriptions remaining"))})}u=!0})}onceMeltPaid(t,e){return this.waitUntilPaid(this.meltQuotePaid.bind(this),t,e,"Timeout waiting for melt paid")}proofStatesStream(t,e){return async function*(){const n=[];let s=!1,i=null;const o=e?.maxBuffer&&e.maxBuffer>0?e.maxBuffer:1/0,c=e?.drop??"oldest",a=()=>{const f=i;i=null,f&&f()},u=f=>{if(n.length>=o)if(c==="oldest"){const d=n.shift();if(d!==void 0)try{e?.onDrop?.(d)}catch{}n.push(f)}else{try{e?.onDrop?.(f)}catch{}return}else n.push(f);a()},l=this.proofStateUpdates(t,f=>{u(f)},()=>{s=!0,a()},{signal:e?.signal}),h=()=>{s=!0,a()};try{for(e?.signal&&(e.signal.aborted?h():e.signal.addEventListener("abort",h,{once:!0}));!s||n.length;){for(;n.length;)yield n.shift();if(s)break;await new Promise(f=>i=f)}}finally{Dt(l),e?.signal&&e.signal.removeEventListener("abort",h)}}.call(this)}group(){const t=[];let e=!1;const n=(()=>{if(!e)for(e=!0;t.length;)Dt(t.pop())});return n.add=s=>e?(Dt(s),s):(t.push(s),s),Object.defineProperty(n,"cancelled",{get:()=>e,enumerable:!0}),n}}class io{constructor(t){this.src=t}async peekNext(t){return(await this.src.reserve(t,0)).start}async advanceToAtLeast(t,e){await this.src.advanceToAtLeast(t,e)}async setNext(t,e){if(typeof this.src.setNext=="function"){await this.src.setNext(t,e);return}throw new Error("CounterSource does not support setNext()")}async snapshot(){if(typeof this.src.snapshot=="function")return await this.src.snapshot();throw new Error("CounterSource does not support snapshot()")}}const br="__PENDING__";class an{constructor(t,e){if(this._seed=void 0,this._unit="sat",this._mintInfo=void 0,this._denominationTarget=3,this._secretsPolicy="auto",this._boundKeysetId=br,this.swap=this.send.bind(this),this.ops=new Ji(this),this.on=new so(this),this._logger=e?.logger??X,this._selectProofs=e?.selectProofs??Xi,this.mint=typeof t=="string"?new cn(t,{authProvider:e?.authProvider,logger:this._logger}):t,this._unit=e?.unit??this._unit,this._boundKeysetId=e?.keysetId??this._boundKeysetId,e?.bip39seed&&(this.failIf(!(e.bip39seed instanceof Uint8Array),"bip39seed must be a valid Uint8Array",{bip39seed:e.bip39seed}),this._seed=e.bip39seed),this._secretsPolicy=e?.secretsPolicy??this._secretsPolicy,e?.counterSource?this._counterSource=e.counterSource:this._counterSource=new Ya(e?.counterInit),this.counters=new io(this._counterSource),this._keyChain=new kt(this.mint,this._unit),this._denominationTarget=e?.denominationTarget??this._denominationTarget,e?.keysets&&e?.keys&&e?.mintInfo){const n=Array.isArray(e.keys)?e.keys:[e.keys],s=kt.mintToCacheDTO(this._unit,this.mint.mintUrl,e.keysets,n);this.loadMintFromCache(e.mintInfo,s)}}fail(t,e){return be(t,this._logger,e)}failIf(t,e,n){return hn(t,e,this._logger,n)}failIfNullish(t,e,n){return Er(t,e,this._logger,n)}safeCallback(t,e,n){Xt(t,e,this._logger,n)}assertAmount(t,e){try{en(t,!1)}catch(n){this.fail(n.message,{op:e,amount:t})}}async loadMint(t){const e=[];(!this._mintInfo||t)&&e.push(this.mint.getInfo().then(n=>(this._mintInfo=new me(n),null))),e.push(this._keyChain.init(t).then(()=>null)),await Promise.all(e),this.finishInit()}loadMintFromCache(t,e){this._mintInfo=new me(t),this._keyChain.loadFromCache(e),this.finishInit()}finishInit(){const t=this._keyChain.getCheapestKeyset().id;if(this._logger.debug("KeyChain",{keychain:this._keyChain.cache}),this._boundKeysetId===br)this._boundKeysetId=t;else{const e=this._keyChain.getKeyset(this._boundKeysetId);this.failIf(!e.hasKeys,"Wallet keyset has no keys",{keyset:e.id})}this.getMintInfo()}get keyChain(){return this._keyChain}get unit(){return this._unit}getMintInfo(){return this.failIfNullish(this._mintInfo,"Mint info not initialized; call loadMint or loadMintFromCache first"),this._mintInfo}get keysetId(){return this.failIf(this._boundKeysetId===br,"Wallet not initialised, call loadMint or loadMintFromCache first"),this._boundKeysetId}getKeyset(t){const e=this._keyChain.getKeyset(t??this.keysetId);return this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),e}get logger(){return this._logger}async reserveFor(t,e){return e<=0?{start:0,count:0}:this._counterSource.reserve(t,e)}countersNeeded(t){return t.type!=="deterministic"||t.counter!==0?0:(t.denominations??[]).length}async addCountersToOutputTypes(t,...e){const n=e.filter(u=>u.type==="deterministic"&&u.counter>0&&(u.denominations?.length??0)>0);if(n.length>1){const u=n.map(l=>({start:l.counter,end:l.counter+l.denominations.length})).sort((l,h)=>l.start-h.start);for(let l=1;l<u.length;l++)this.failIf(u[l].start<u[l-1].end,"Manual counter ranges overlap",{keysetId:t,prev:u[l-1],cur:u[l]})}if(n.length>0){const u=Math.max(...n.map(l=>l.counter+l.denominations.length));await this._counterSource.advanceToAtLeast(t,u),this._logger.debug("Counter source advanced to respect manual deterministic counters",{keysetId:t,maxManualEnd:u})}const s=e.reduce((u,l)=>u+this.countersNeeded(l),0);if(s===0)return{outputTypes:e};const i=await this.reserveFor(t,s);let o=i.start;const c=e.map(u=>{if(u.type==="deterministic"&&u.counter===0){const l=u.denominations?.length??0;if(l>0){const h={...u,counter:o};return o+=l,h}}return u}),a={keysetId:t,start:i.start,count:i.count,next:i.start+i.count};return this.on._emitCountersReserved(a),{outputTypes:c,used:a}}bindKeyset(t){const e=this._keyChain.getKeyset(t);this.failIf(e.unit!==this._unit,"Keyset unit does not match wallet unit",{keyset:e.id,unit:e.unit,walletUnit:this._unit}),this.failIf(!e.hasKeys,"Keyset has no keys loaded",{keyset:e.id}),this._boundKeysetId=e.id,this._logger.debug("Wallet bound to keyset",{keysetId:e.id,unit:e.unit,feePPK:e.fee})}withKeyset(t,e){const n=new an(this.mint,{keysetId:t,bip39seed:this._seed,secretsPolicy:this._secretsPolicy,logger:this._logger,counterSource:e?.counterSource??this._counterSource});return n.loadMintFromCache(this.getMintInfo().cache,this._keyChain.cache),n}defaultOutputType(){return this._secretsPolicy==="random"?{type:"random"}:this._secretsPolicy==="deterministic"?(this.failIfNullish(this._seed,"Deterministic policy requires a seed"),{type:"deterministic",counter:0}):this._seed?{type:"deterministic",counter:0}:{type:"random"}}configureOutputs(t,e,n,s=!1,i=[]){let o=t;if(n.type==="custom"){this.failIf(s,"The custom OutputType does not support automatic fee inclusion");const a=ct.sumOutputAmounts(n.data);return this.failIf(a!==t,`Custom output data total (${a}) does not match amount (${t})`),n}let c=n.denominations??[];if(c.length===0&&i.length>0&&(c=Oi(i,o,e.keys,this._denominationTarget)),c=vt(o,e.keys,c),s){let a=this.getFeesForKeyset(c.length,e.id),u=vt(a,e.keys);for(;this.getFeesForKeyset(c.length+u.length,e.id)>a;)a++,u=vt(a,e.keys);o+=a,c=[...c,...u]}return{...n,denominations:c}}preparedTotal(t){return t.type==="custom"?ct.sumOutputAmounts(t.data):(t.denominations??[]).reduce((n,s)=>n+s,0)}createOutputData(t,e,n){if(this.failIf(t<0,"Amount was negative",{amount:t}),n.type!="custom"&&n.denominations&&n.denominations.length>0){const i=n.denominations.reduce((o,c)=>o+c,0);this.failIf(i!==t,"Denominations do not sum to the expected amount",{splitSum:i,expected:t})}let s;switch(n.type){case"random":s=ct.createRandomData(t,e,n.denominations);break;case"deterministic":this.failIfNullish(this._seed,"Deterministic outputs require a seed configured in the wallet"),s=ct.createDeterministicData(t,this._seed,n.counter,e,n.denominations);break;case"p2pk":s=ct.createP2PKData(n.options,t,e,n.denominations);break;case"factory":{s=vt(t,e.keys,n.denominations).map(o=>n.factory(o,e));break}case"custom":{s=n.data;const i=ct.sumOutputAmounts(s);this.failIf(i!==t,`Custom output data total (${i}) does not match amount (${t})`);break}default:this.fail("Invalid OutputType")}return s}createSwapTransaction(t,e,n=[]){t=this._prepareInputsForMint(t);const s=[...e,...n],i=s.map((h,f)=>f);de(t)||i.sort((h,f)=>s[h].blindedMessage.amount-s[f].blindedMessage.amount);const o=[...Array.from({length:e.length},()=>!0),...Array.from({length:n.length},()=>!1)],c=i.map(h=>s[h]),a=i.map(h=>o[h]),u=c.map(h=>h.blindedMessage);return this._logger.debug("createSwapTransaction:",{indices:i,sortedKeepVector:a}),{payload:{inputs:t,outputs:u},outputData:c,keepVector:a,sortedIndices:i}}async receive(t,e,n){const s=await this.prepareSwapToReceive(t,e,n),{keep:i}=await this.completeSwap(s,e?.privkey);return i}async prepareSwapToReceive(t,e,n){const{keysetId:s,requireDleq:i,proofsWeHave:o,onCountersReserved:c}=e||{};n=n??this.defaultOutputType();const a=typeof t=="string"?this.decodeToken(t):t,u=ur(a.mint);this.failIf(u!==this.mint.mintUrl,"Token belongs to a different mint",{token:u,wallet:this.mint.mintUrl}),this.failIf(a.unit!==this._unit,"Token is not in wallet unit",{token:a.unit,wallet:this._unit});let l=[];({proofs:l}=a);const h=Ut(l);this.failIf(h===0,"Token contains no proofs",{proofs:l}),this.assertAmount(h,"prepareSwapToReceive");const f=this.getKeyset(s);if(i)for(const K of l){const B=this._keyChain.getKeyset(K.id);hr(K,B)||this.fail("Token contains proofs with invalid or missing DLEQ")}const d=this.getFeesForProofs(l),y=h-d;let w=this.configureOutputs(y,f,n,!1,o);const b=await this.addCountersToOutputTypes(f.id,w);[w]=b.outputTypes,b.used&&this.safeCallback(c,b.used,{op:"receive"}),this._logger.debug("receive counter",{counter:b.used,receiveOT:w});const P=this.createOutputData(this.preparedTotal(w),f,w);return{amount:y,fees:d,keysetId:f.id,inputs:l,keepOutputs:P}}sendOffline(t,e,n){this.assertAmount(t,"sendOffline");const{requireDleq:s=!1,includeFees:i=!1,exactMatch:o=!0}=n||{};s&&(e=e.filter(l=>l.dleq!=null)),this.failIf(Ut(e)<t,"Not enough funds available to send");const{keep:c,send:a}=this.selectProofsToSend(e,t,i,o),u=this._prepareInputsForMint(a,s);return{keep:c,send:u}}async send(t,e,n,s){this.assertAmount(t,"send");const{keysetId:i,includeFees:o=!1}=n||{};s=s??{send:this.defaultOutputType(),keep:this.defaultOutputType()};try{const a=this.defaultOutputType().type==="deterministic",u=d=>!d||d.type==="random"&&(!d.denominations||d.denominations.length===0);if(i||a||!u(s.send)||s.keep&&!u(s.keep)){const d=[];throw i&&d.push("keysetId override"),a&&d.push("wallet default is deterministic"),u(s.send)||d.push("non-default send output type"),s.keep&&!u(s.keep)&&d.push("non-default keep output type"),new Error(`Options require a swap: ${d.join(", ")}`)}const{keep:l,send:h}=this.sendOffline(t,e,{includeFees:o,exactMatch:!0,requireDleq:!1}),f=o?this.getFeesForProofs(h):0;if(Ut(h)===t+f)return this._logger.info("Successful exactMatch offline selection!"),{keep:l,send:h}}catch(a){const u=a instanceof Error?a.message:"Unknown error";this._logger.debug("ExactMatch offline selection failed.",{e:u})}const c=await this.prepareSwapToSend(t,e,n,s);return await this.completeSwap(c,n?.privkey)}async prepareSwapToSend(t,e,n,s){const{keysetId:i,includeFees:o=!1,onCountersReserved:c}=n||{};s=s??{send:this.defaultOutputType(),keep:this.defaultOutputType()};const a=this.getKeyset(i);let u=this.configureOutputs(t,a,s.send??this.defaultOutputType(),o);const l=this.preparedTotal(u),{keep:h,send:f}=this.selectProofsToSend(e,l,!0);if(f.length===0)throw new Error("Not enough funds available to send");const d=Ut(f),y=this.getFeesForProofs(f),w=d-y-l;this.failIf(w<0,"Not enough funds available for swap",{selectedSum:d,swapFee:y,sendAmount:l,changeAmount:w});let b=this.configureOutputs(w,a,s.keep??this.defaultOutputType(),!1,n?.proofsWeHave);const P=this.preparedTotal(b),K=await this.addCountersToOutputTypes(a.id,u,b);[u,b]=K.outputTypes,K.used&&this.safeCallback(c,K.used,{op:"send"}),this._logger.debug("send counters",{counter:K.used,sendOT:u,keepOT:b});const B=this.createOutputData(l,a,u),q=this.createOutputData(P,a,b);return{amount:t,fees:y,keysetId:a.id,inputs:f,sendOutputs:B,keepOutputs:q,unselectedProofs:h}}async completeSwap(t,e){const n=t?.keepOutputs?t.keepOutputs:[],s=t.sendOutputs?t.sendOutputs:[],i=t.unselectedProofs?t.unselectedProofs:[];e&&(t.inputs=this.signP2PKProofs(t.inputs,e,[...n,...s]));const o=this.createSwapTransaction(t.inputs,n,s),{signatures:c}=await this.mint.swap(o.payload);this.failIf(c.length<o.outputData.length,`Mint returned ${c.length} signatures, expected ${o.outputData.length}`);const a=this.getKeyset(t.keysetId),u=o.outputData.map((y,w)=>y.toProof(c[w],a)),l=Array(u.length),h=Array(o.keepVector.length);o.sortedIndices.forEach((y,w)=>{h[y]=o.keepVector[w],l[y]=u[w]});const f=[],d=[];return l.forEach((y,w)=>{h[w]?f.push(y):d.push(y)}),this._logger.debug("SEND COMPLETED",{unselectedProofs:i.map(y=>y.amount),keepProofs:f.map(y=>y.amount),sendProofs:d.map(y=>y.amount)}),{keep:[...f,...i],send:d}}selectProofsToSend(t,e,n=!1,s=!1){this.assertAmount(e,"selectProofsToSend");const{keep:i,send:o}=this._selectProofs(t,e,this._keyChain,n,s);return{keep:i,send:o}}signP2PKProofs(t,e,n,s){if(!de(t))return Jn(t,e,this._logger);this.failIfNullish(n,"OutputData is required for SIG_ALL proof signing."),ti(t);const[i,...o]=t;let c=i;const a=[ri(t,n,s),ni(t,n,s),ei(t,n,s)];for(const u of a)c=Jn([c],e,this._logger,u)[0];return[c,...o]}getFeesForProofs(t){const e=t.reduce((n,s)=>n+this.getProofFeePPK(s),0);return Math.ceil(e/1e3)}getProofFeePPK(t){try{return this._keyChain.getKeyset(t.id).fee}catch(e){this.fail(`Could not get fee. No keyset found for keyset id: ${t.id}`,{e,keychain:this._keyChain.getKeysets()})}}getFeesForKeyset(t,e){try{const n=this._keyChain.getKeyset(e).fee;return Math.floor(Math.max((t*n+999)/1e3,0))}catch(n){this.fail(`No keyset found with ID ${e}`,{e:n})}}_prepareInputsForMint(t,e=!1){return t.map(n=>{const s=n.witness&&typeof n.witness!="string"?JSON.stringify(n.witness):n.witness,{dleq:i,p2pk_e:o,...c}=n;return e&&i?{...c,dleq:i,witness:s}:{...c,witness:s}})}decodeToken(t){const e=this._keyChain.getAllKeysetIds();return qi(t,e)}async batchRestore(t=300,e=100,n=0,s){const i=Math.ceil(t/e),o=[];let c,a=0;for(;a<i;){const u=await this.restore(n,e,{keysetId:s});u.proofs.length>0?(a=0,o.push(...u.proofs),c=u.lastCounterWithSignature):a++,n+=e}return{proofs:o,lastCounterWithSignature:c}}async restore(t,e,n){const{keysetId:s}=n||{},i=this.getKeyset(s);this.failIfNullish(this._seed,"Cashu Wallet must be initialized with a seed to use restore");const o=Array(e).fill(0),c=ct.createDeterministicData(0,this._seed,t,i,o),{outputs:a,signatures:u}=await this.mint.restore({outputs:c.map(d=>d.blindedMessage)}),l={};a.forEach((d,y)=>l[d.B_]=u[y]);const h=[];let f;for(let d=0;d<c.length;d++){const y=l[c[d].blindedMessage.B_];y&&(f=t+d,c[d].blindedMessage.amount=y.amount,h.push(c[d].toProof(y,i)))}return{proofs:h,lastCounterWithSignature:f}}async createMintQuote(t,e){return this.createMintQuoteBolt11(t,e)}async createMintQuoteBolt11(t,e){this.assertAmount(t,"createMintQuoteBolt11"),e&&(this.getMintInfo().supportsNut04Description("bolt11",this._unit)||this.fail("Mint does not support description for bolt11"));const n={unit:this._unit,amount:t,description:e},s=await this.mint.createMintQuoteBolt11(n);return{...s,amount:s.amount||t,unit:s.unit||this._unit}}async createLockedMintQuote(t,e,n){this.assertAmount(t,"createLockedMintQuote");const{supported:s}=this.getMintInfo().isSupported(20);this.failIf(!s,"Mint does not support NUT-20");const i={unit:this._unit,amount:t,description:n,pubkey:e},o=await this.mint.createMintQuoteBolt11(i);this.failIf(typeof o.pubkey!="string","Mint returned unlocked mint quote");const c=o.pubkey;return{...o,pubkey:c,amount:o.amount||t,unit:o.unit||this._unit}}async createMintQuoteBolt12(t,e){const n=this.getMintInfo();e?.description&&!n.supportsNut04Description("bolt12",this._unit)&&this.fail("Mint does not support description for bolt12");const s={pubkey:t,unit:this._unit,amount:e?.amount,description:e?.description};return this.mint.createMintQuoteBolt12(s)}async checkMintQuote(t){return this.checkMintQuoteBolt11(t)}async checkMintQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMintQuoteBolt11(e);return typeof t=="string"?n:{...n,amount:n.amount||t.amount,unit:n.unit||t.unit}}async checkMintQuoteBolt12(t){return this.mint.checkMintQuoteBolt12(t)}async mintProofs(t,e,n,s){return this._mintProofs("bolt11",t,e,n,s)}async mintProofsBolt11(t,e,n,s){return this._mintProofs("bolt11",t,e,n,s)}async mintProofsBolt12(t,e,n,s,i){return this._mintProofs("bolt12",t,e,{...s,privkey:n},i)}async _mintProofs(t,e,n,s,i){this.assertAmount(e,`_mintProofs: ${t}`),i=i??this.defaultOutputType();const{privkey:o,keysetId:c,proofsWeHave:a,onCountersReserved:u}=s??{},l=this.getKeyset(c);let h=this.configureOutputs(e,l,i,!1,a);const f=this.preparedTotal(h),d=await this.addCountersToOutputTypes(l.id,h);[h]=d.outputTypes,d.used&&this.safeCallback(u,d.used,{op:"mintProofs"}),this._logger.debug("mint counter",{counter:d.used,mintOT:h});const y=this.createOutputData(f,l,h),w=y.map(K=>K.blindedMessage),b={outputs:w,quote:typeof n=="string"?n:n.quote};if(typeof n!="string"&&n.pubkey){this.failIf(!o,"Can not sign locked quote without private key");const K=pi(o,n.quote,w);b.signature=K}let P;return t==="bolt12"?{signatures:P}=await this.mint.mintBolt12(b):{signatures:P}=await this.mint.mintBolt11(b),this.failIf(P.length!==y.length,`Mint returned ${P.length} signatures, expected ${y.length}`),this._logger.debug("MINT COMPLETED",{amounts:y.map(K=>K.blindedMessage.amount)}),y.map((K,B)=>K.toProof(P[B],l))}async createMeltQuote(t,e){return this.createMeltQuoteBolt11(t,e)}async createMeltQuoteBolt11(t,e){e!==void 0&&(this.failIf(Vi(t),"amountMsat supplied but invoice already contains an amount. Leave amountMsat undefined for non-zero invoices."),this.assertAmount(e,"createMeltQuoteBolt11"));const n=this._mintInfo?.supportsAmountless?.("bolt11",this._unit)??!1,s={unit:this._unit,request:t,...n&&e!==void 0?{options:{amountless:{amount_msat:e}}}:{}},i=await this.mint.createMeltQuoteBolt11(s);return{...i,unit:i.unit||this._unit,request:i.request||t}}async createMeltQuoteBolt12(t,e){return this.mint.createMeltQuoteBolt12({unit:this._unit,request:t,options:e?{amountless:{amount_msat:e}}:void 0})}async createMultiPathMeltQuote(t,e){this.assertAmount(e,"createMultiPathMeltQuote");const{supported:n,params:s}=this.getMintInfo().isSupported(15);this.failIf(!n,"Mint does not support NUT-15"),this.failIf(!s?.some(c=>c.method==="bolt11"&&c.unit===this._unit),`Mint does not support MPP for bolt11 and ${this._unit}`);const i={unit:this._unit,request:t,options:{mpp:{amount:e}}};return{...await this.mint.createMeltQuoteBolt11(i),request:t,unit:this._unit}}async checkMeltQuote(t){return this.checkMeltQuoteBolt11(t)}async checkMeltQuoteBolt11(t){const e=typeof t=="string"?t:t.quote,n=await this.mint.checkMeltQuoteBolt11(e);return typeof t=="string"?n:{...n,request:t.request,unit:t.unit}}async checkMeltQuoteBolt12(t){return this.mint.checkMeltQuoteBolt12(t)}async meltProofs(t,e,n,s){return this.meltProofsBolt11(t,e,n,s)}async meltProofsBolt11(t,e,n,s){const i=await this.prepareMelt("bolt11",t,e,n,s),o=typeof n?.onChangeOutputsCreated=="function";return this.completeMelt(i,n?.privkey,o)}async meltProofsBolt12(t,e,n,s){const i=await this.prepareMelt("bolt12",t,e,n,s),o=typeof n?.onChangeOutputsCreated=="function";return this.completeMelt(i,n?.privkey,o)}async prepareMelt(t,e,n,s,i){i=i??this.defaultOutputType();const{keysetId:o,onChangeOutputsCreated:c,onCountersReserved:a}=s||{},u=this.getKeyset(o),l=Ut(n),h=l-e.amount;let f=[];if(this.failIf(h<0,"Not enough proofs to cover amount + fee reserve",{sendAmount:l,quoteAmount:e.amount}),i.type==="custom")f=i.data;else if(h>0){let y=Math.ceil(Math.log2(h))||1;y<0&&(y=0);const w=y?new Array(y).fill(0):[];this._logger.debug("Creating NUT-08 blanks for fee reserve",{feeReserve:h,denominations:w});let b={...i,denominations:w};const P=await this.addCountersToOutputTypes(u.id,b);[b]=P.outputTypes,P.used&&this.safeCallback(a,P.used,{op:"meltProofs"}),this._logger.debug("melt counter",{counter:P.used,meltOT:b}),f=this.createOutputData(0,u,b)}const d={method:t,inputs:n,outputData:f,keysetId:u.id,quote:e};if(f.length>0){const y={method:t,payload:{quote:e.quote,inputs:n,outputs:f.map(w=>w.blindedMessage)},outputData:f,keyset:u,quote:e};this.safeCallback(c,y,{op:"meltProofs"}),this.on._emitMeltBlanksCreated(y)}return d}async completeMelt(t,e,n){t=this.maybeConvertMeltBlanks(t);let s=t.inputs;const i=t.outputData.map(f=>f.blindedMessage),o=t.quote.quote,c=this.getKeyset(t.keysetId);e&&(s=this.signP2PKProofs(s,e,t.outputData,o)),s=this._prepareInputsForMint(s);const a={quote:o,inputs:s,outputs:i},u=t.method==="bolt11"?await this.mint.meltBolt11(a,{preferAsync:n}):await this.mint.melt(t.method,a,{preferAsync:n});this.failIf((u.change?.length??0)>t.outputData.length,`Mint returned ${u.change?.length??0} signatures, but only ${t.outputData.length} blanks were provided`);const l=u.change?.map((f,d)=>t.outputData[d].toProof(f,c))??[];return n?this._logger.debug("ASYNC MELT REQUESTED",u):this._logger.debug("MELT COMPLETED",{changeAmounts:l.map(f=>f.amount)}),{quote:{...t.quote,...u},change:l}}maybeConvertMeltBlanks(t){if(!("payload"in t))return t;this._logger.warn("MeltBlanks objects and the meltBlanksCreated / onChangeOutputsCreated events are deprecated. Please use wallet.prepareMelt() to create a MeltPreview instead.");const{method:e,payload:n,outputData:s,keyset:i,quote:o}=t;return{method:e,inputs:n.inputs,outputData:s,keysetId:i.id,quote:o}}async checkProofsStates(t){const e=new TextEncoder,n=t.map(o=>Vt(e.encode(o.secret)).toHex(!0)),s=100,i=[];for(let o=0;o<n.length;o+=s){const c=n.slice(o,o+s),{states:a}=await this.mint.check({Ys:c}),u={};a.forEach(l=>{u[l.Y]=l});for(let l=0;l<c.length;l++){const h=u[c[l]];this.failIfNullish(h,"Could not find state for proof with Y: "+c[l]),i.push(h)}}return i}async groupProofsByState(t){const e=await this.checkProofsStates(t),n={unspent:[],pending:[],spent:[]};for(let s=0;s<e.length;s++){const i=t[s];switch(e[s].state){case sn.UNSPENT:n.unspent.push(i);break;case sn.PENDING:n.pending.push(i);break;case sn.SPENT:n.spent.push(i);break}}return n}}const ln=class ln{constructor(t,e){this.tokens={},this.pool=[],this.desiredPoolSize=10,this.maxPerMint=10,this.mintUrl=t,this.req=e?.request??Ar,this.logger=e?.logger??X,this.desiredPoolSize=Math.max(1,e?.desiredPoolSize??this.desiredPoolSize),this.maxPerMint=Math.max(1,e?.maxPerMint??this.maxPerMint)}attachOIDC(t){return this.oidc=t,this.oidc.addTokenListener(e=>this.updateFromOIDC(e)),this}get poolSize(){return this.pool.length}get poolTarget(){return this.desiredPoolSize}get activeAuthKeysetId(){try{return this.keychain?.getCheapestKeyset().id}catch{return}}get hasCAT(){return!!this.tokens.accessToken}getCAT(){return this.tokens.accessToken}setCAT(t){this.tokens.accessToken=t,t||(this.tokens.refreshToken=void 0,this.tokens.expiresAt=void 0)}async ensureCAT(t){return this.validForAtLeast(t)?this.tokens.accessToken:!this.oidc||!this.tokens.refreshToken?this.tokens.accessToken:(this.inflightRefresh||(this.inflightRefresh=(async()=>{try{const e=await this.oidc.refresh(this.tokens.refreshToken);this.updateFromOIDC(e)}catch(e){this.logger.warn("AuthManager: CAT refresh failed",{err:e})}finally{this.inflightRefresh=void 0}})()),await this.inflightRefresh,this.validForAtLeast(0)?this.tokens.accessToken:void 0)}validForAtLeast(t=ln.MIN_VALID_SECS){const{accessToken:e,expiresAt:n}=this.tokens;return e?n?Date.now()+t*1e3<n:!0:!1}updateFromOIDC(t){if(!t.access_token)return;const e=Date.now();if(this.tokens.accessToken=t.access_token,t.refresh_token&&(this.tokens.refreshToken=t.refresh_token),typeof t.expires_in=="number"&&t.expires_in>0)this.tokens.expiresAt=e+t.expires_in*1e3;else{const n=this.parseJwtExpSec(t.access_token);this.tokens.expiresAt=n?n*1e3:void 0}this.logger.debug("AuthManager: OIDC tokens updated",{expiresAt:this.tokens.expiresAt})}async ensure(t){if(await this.init(),this.pool.length>=t)return;const e=Math.max(this.desiredPoolSize,t),n=this.getBatMaxMint(),s=Math.min(e-this.pool.length,n);s<=0||await this.topUp(s)}async getBlindAuthToken({method:t,path:e}){return this.info&&!this.info.requiresBlindAuthToken(t,e)&&this.logger.warn("Endpoint is not marked as protected by NUT-22; still issuing BAT",{method:t,path:e}),this.withLock(async()=>{if(await this.ensure(1),this.pool.length===0)throw new Error("AuthManager: no BATs available and minting failed");const n=this.pool.pop();return this.logger.debug("AuthManager: BAT requested",{method:t,path:e,remaining:this.pool.length}),Ja(n)})}importPool(t,e="replace"){e==="replace"&&(this.pool=[]);const n=new Map(this.pool.map(s=>[s.secret,s]));for(const s of t)!s||!s.secret||!s.C||!s.id||n.has(s.secret)||(this.pool.push(s),n.set(s.secret,s))}exportPool(){return this.pool.map(t=>({...t,dleq:t.dleq?{...t.dleq}:void 0}))}parseJwtExpSec(t){if(!t)return;const e=t.split(".");if(e.length===3)try{const n=N.toString(N.fromBase64(e[1])),s=JSON.parse(n),i=typeof s.exp=="number"?s.exp:Number(s.exp);if(Number.isFinite(i)&&i>0)return i}catch{this.logger.warn("JWT access token was malformed.",{token:t})}}async withLock(t){const e=this.lockChain??Promise.resolve();let n;const s=new Promise(o=>{n=o}),i=e.then(()=>s);this.lockChain=i;try{return await e,await t()}finally{n(),this.lockChain===i&&(this.lockChain=void 0)}}async init(){if(!this.info){const t=await this.req({endpoint:gt(this.mintUrl,"/v1/info"),method:"GET"});this.info=new me(t)}if(!this.keychain){const[t,e]=await Promise.all([this.req({endpoint:gt(this.mintUrl,"/v1/auth/blind/keysets"),method:"GET"}),this.req({endpoint:gt(this.mintUrl,"/v1/auth/blind/keys"),method:"GET"})]);this.keychain=new kt(this.mintUrl,"auth",t.keysets,e.keysets),this.keychain.getCheapestKeyset()}}getBatMaxMint(){if(!this.info)throw new Error("AuthManager: mint info not loaded");const e=this.info.nuts[22]?.bat_max_mint??this.maxPerMint;return Math.max(1,Math.min(this.maxPerMint,e))}getActiveKeys(){if(!this.keychain)throw new Error("AuthManager: keyset not loaded for active keyset");return this.keychain.getCheapestKeyset()}async topUp(t){if(!this.info)throw new Error("AuthManager: mint info not loaded");const e=this.info.requiresClearAuthToken("POST","/v1/auth/blind/mint");let n;if(e&&(n=await this.ensureCAT(),!n))throw new Error("AuthManager: Clear-auth token required for /v1/auth/blind/mint but not available. Authenticate with the mint to obtain a CAT first.");const s=this.getActiveKeys(),i=ct.createRandomData(t,s),o={outputs:i.map(l=>l.blindedMessage)},c={};n&&(c["Clear-auth"]=n);const a=await this.req({endpoint:gt(this.mintUrl,"/v1/auth/blind/mint"),method:"POST",headers:c,requestBody:o});if(!Array.isArray(a?.signatures)||a.signatures.length!==i.length)throw new Error("AuthManager: bad BAT mint response");const u=i.map((l,h)=>l.toProof(a.signatures[h],s));for(const l of u)if(!hr(l,s))throw new Error("AuthManager: mint returned BAT with invalid DLEQ");this.pool.push(...u),this.logger.debug("AuthManager: performed topUp",{minted:u.length,pool:this.pool.length})}};ln.MIN_VALID_SECS=30;let un=ln;function Ja(r){const t={id:r.id,secret:r.secret,C:r.C};return`authA${Sr(t)}`}async function tu(r,t){const e=new un(r,{desiredPoolSize:t?.authPool??10,logger:t?.logger}),n=new cn(r,{authProvider:e,logger:t?.logger}),s=await n.oidcAuth({...t?.oidc,logger:t?.logger,onTokens:o=>e.setCAT(o.access_token)});e.attachOIDC(s);const i=new an(n,{authProvider:e,logger:t?.logger});return await i.loadMint(),{mint:n,auth:e,oidc:s,wallet:i}}return g.AuthManager=un,g.CheckStateEnum=sn,g.ConsoleLogger=ao,g.HttpResponseError=rt,g.KeyChain=kt,g.Keyset=Yt,g.MeltBuilder=wr,g.MeltQuoteState=Zt,g.MessageNode=Hi,g.MessageQueue=$i,g.Mint=cn,g.MintBuilder=mr,g.MintInfo=me,g.MintOperationError=we,g.MintQuoteState=rn,g.NetworkError=mt,g.OIDCAuth=on,g.OutputData=ct,g.P2BK_DST=Yn,g.P2PKBuilder=yr,g.PaymentRequest=pe,g.PaymentRequestTransportType=ge,g.ReceiveBuilder=eo,g.SendBuilder=to,g.WSConnection=Gi,g.Wallet=an,g.WalletCounters=io,g.WalletEvents=so,g.WalletOps=Ji,g.assertSecretKind=jn,g.assertSigAllInputs=ti,g.bigIntStringify=La,g.blindMessage=ce,g.buildInterimP2PKSigAllMessage=ni,g.buildLegacyP2PKSigAllMessage=ri,g.buildP2PKSigAllMessage=ei,g.bytesToNumber=Oa,g.checkResponse=Da,g.constructProofFromPromise=Ms,g.createAuthWallet=tu,g.createBlindSignature=qc,g.createDLEQProof=fa,g.createHTLCHash=li,g.createHTLCsecret=ga,g.createNewMintKeys=na,g.createP2PKsecret=ia,g.createRandomBlindedMessage=Fc,g.createRandomRawBlindedMessage=Bs,g.createRandomSecretKey=$e,g.createSecret=Wn,g.decodePaymentRequest=qa,g.deepEqual=fr,g.deriveBlindingFactor=ai,g.deriveKeysetId=nn,g.deriveP2BKBlindedPubkeys=$s,g.deriveP2BKSecretKey=js,g.deriveP2BKSecretKeys=Ws,g.deriveSecret=ci,g.deserializeMintKeys=ea,g.deserializeProof=Hc,g.getDataField=zn,g.getDecodedToken=qi,g.getDecodedTokenBinary=ja,g.getEncodedToken=Ra,g.getEncodedTokenBinary=Wa,g.getEncodedTokenV3=Li,g.getEncodedTokenV4=Ni,g.getHTLCWitnessPreimage=di,g.getKeepAmounts=Oi,g.getKeysetAmounts=or,g.getKeysetIdInt=Is,g.getP2PKExpectedKWitnessPubkeys=ua,g.getP2PKExpectedWitnessPubkeys=Xn,g.getP2PKLockState=fe,g.getP2PKLocktime=Gs,g.getP2PKNSigs=zs,g.getP2PKNSigsRefund=Qs,g.getP2PKSigFlag=Ze,g.getP2PKWitnessPubkeys=Qe,g.getP2PKWitnessRefundkeys=Gt,g.getP2PKWitnessSignatures=Ye,g.getPubKeyFromPrivKey=Hs,g.getSecretData=Gn,g.getSecretKind=Vn,g.getTag=Ge,g.getTagInt=ze,g.getTagScalar=Zn,g.getTags=Qn,g.getTokenMetadata=Na,g.getValidSigners=We,g.handleTokens=ar,g.hasCorrespondingKey=cr,g.hasNonHexId=tn,g.hasP2PKSignedProof=oa,g.hasTag=sa,g.hasValidDleq=hr,g.hashToCurve=Vt,g.hash_e=Dn,g.hexToNumber=ye,g.injectWebSocketImpl=go,g.invoiceHasAmountInHRP=Vi,g.isHTLCSpendAuthorised=ya,g.isObj=ht,g.isP2PKSigAll=de,g.isP2PKSpendAuthorised=Xs,g.isValidHex=Nt,g.joinUrls=gt,g.maybeDeriveP2BKPrivateKeys=Js,g.meetsSignerThreshold=$c,g.mergeUInt8Arrays=Fi,g.numberToHexPadded64=Je,g.parseHTLCSecret=pa,g.parseP2PKSecret=ot,g.parseSecret=he,g.pointFromBytes=Dc,g.pointFromHex=Bt,g.sanitizeUrl=ur,g.schnorrSignMessage=qn,g.schnorrVerifyMessage=ae,g.selectProofsRGLI=Xi,g.serializeMintKeys=Fs,g.serializeProof=Ks,g.setGlobalRequestOptions=lo,g.signMintQuote=pi,g.signP2PKProof=Ys,g.signP2PKProofs=Jn,g.signP2PKSecret=ca,g.sortProofsById=Ua,g.splitAmount=vt,g.stripDleq=lr,g.sumProofs=Ut,g.unblindSignature=Cs,g.validateAmount=en,g.verifyDLEQProof=si,g.verifyDLEQProof_reblind=ii,g.verifyHTLCHash=hi,g.verifyHTLCSpendingConditions=fi,g.verifyKeysetId=Fa,g.verifyMintQuoteSignature=ma,g.verifyP2PKSecretSignature=aa,g.verifyP2PKSig=la,g.verifyP2PKSpendingConditions=tr,g.verifyProof=ra,Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),g})({});
//# sourceMappingURL=cashu-ts.iife.js.map
